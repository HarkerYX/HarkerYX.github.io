---
layout: post
title: UML笔记
date: '2023-05-11'
description: 'UML笔记'
categories: ['【👉👉👉 技能专栏】','【UML】']
tags: [技能,UML]
---

### **UML**

[UML Tutorial (tutorialspoint.com)](https://www.tutorialspoint.com/uml/index.htm)

[UML Message defines specific kind of communication between lifelines of an interaction. (uml-diagrams.org)](https://www.uml-diagrams.org/interaction-message.html)


### **UML 介绍**

- 所谓UML（Unified Modeling Language，统一建模语言），一种用来对软件密集系统进行可视化建模的语言。是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言


**UML做到了什么，让人们愿意为之喝彩？**

- 答案就是，它统一了各种方法对不同类型的系统、不同开发阶段以及不同内部概念的不同观点，从而有效的消除了各种建模语言之间不必要的差异。它是一种通用的建模语言，可以为许多面向对象建模方法的用户广泛使用


**常用工具：StarUML 、EA 等**
- **详细设计（LLD）**
- **概要设计（HLD）**
- **需求分析文档（SRS）**
- **基本设计（BD）**
- **详细设计（DD）**
- **功能设计（FD）**

**HLD**：概要设计说明书，编制的目的是说明对程序系统的设计考虑，包括程序系统的基本处理流程、程序系统的组织结构、模块划分、功能分配、接口设计、运行设计、安全设计、数据结构设计和出错处理设计等，为程序的详细设计提供基础

**LLD**：详细设计说明书，编制目的是说明一个软件系统各个层次中的每一个程序的设计考虑，如果一个软件系统比较简单，层次很少，本文件可以不单独编写，有关内容合并入概要设计说明书

**DD：**详细设计，是软件工程中软件开发的一个步骤，是对概要设计的一个细化，详细设计每个模块实现算法，所需的局部结构

**流程: SRS->AD->HLD->DD**
- AD 文档 的接口是 提供对外的接口
- HLD 文档 的接口是 内部的接口
- DD 文档 是接口的实现逻辑


**九大图在各个阶段的使用：（BD：基本设计，FD：功能设计，DD:详细设计）**

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Vsc2ExNQ==,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:80%;" />
</div>


**九大图之间的关系：**

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/20181206104744401.png" alt="img" style="zoom:70%;" />
</div>


#### **UML的分类**

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/image-20211013141441589.png" alt="img" style="zoom:90%;" />
</div>


##### **UML图有哪些？**

- **UML图分为结构图和行为图**
- **结构图**分为类图、轮廓图、组件图、组合结构图、对象图、部署图、包图
- **行为图**又分活动图、用例图、状态机图和交互图
  - **交互图**又分为序列图、时序图、通讯图、交互概览图


**结构型的图(Structure Diagram)**
- 类图(Class Diagram)
- 对象图(Object Diagram)
- 构件图(Component Diagram)
- 部署图(Deployment Diagram)
- 包图(Package Diagram)

**行为型的图(Behavior Diagram)**
- 活动图(Activity Diagram)
- 状态机图(State Machine Diagram)
- 顺序图(Sequence Diagram)
- 通信图(Communication Diagram)
- 用例图(Use Case Diagram)
- 时序图(Timing Diagram)

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/image-20211013144421035.png" alt="img" style="zoom:90%;" />
</div>

### **面向对象基础设计原则**

#### **面向对象设计原则概述**

- 衡量软件设计质量的首要标准是该设计是否能满足软件的功能需求。不过，仅仅满足功能性需求的设计并不见得是好的设计。除了功能需求以外，还有很多衡量软件设计质量的标准，例如：
  - 可读性：软件的设计文档是否轻易被其他程序员理解。可读性差的设计会给大型软件的开发和维护过程带来严重的危害
  - 可复用性：软件系统的架构、类、组件等单元能否很容易被本项目的其它部分或者其它项目复用
  - 可扩展性：软件面对需求变化时，功能或性能扩展的难易程度
  - 可维护性：软件维护（主要是指软件错误的修改、遗漏功能的添加等）的难易程度

- 上述衡量标准之间存在紧密的关联。例如，可读性好的软件维护起来就会容易一些，扩展性好的软件复用时往往也会非常简单
- 但是，这些衡量标准大都比较抽象，程序员在开发过程中很难把握。相对而言，以下两个更为具体的衡量标准——内聚度和耦合度——就更直接和实用一些。事实上，如果一个软件的内聚度和耦合度都符合要求，它也就自然具备了比较好的复用性、可扩展性和可维护性

- **内聚度：表示一个应用程序的单个单元所负责的任务数量和多样性**。内聚与单个类或者单个方法单元相关。好的软件设计应该做到高内聚。理想状态下，一个代码单元应该负责一个内聚的任务，也就是说一个任务可以看作是一个逻辑单元。一个方法应该实现一个逻辑操作，一个类应该代表一种类型的实体。内聚原则背后的主要原因是重用：如果一个方法或一个类只负责一个定义明确的事情，那么在不同的上下文环境中，它就能更好地被再次使用。遵循该规则的另一个优点是，当一个应用程序的某些方面需要做出改变时，我们能够在相同单元中找到所有相关的部分。如果一个系统单元只负责一件事情，就说明这个系统单元有很高的内聚度；如果一个系统单元负责了很多不相关的事情，则说明这个系统单元是内聚度很低。**内聚度很高的系统单元通常很容易理解，很容易被复用、扩展和维护**。有一个简单的方法可以粗略判断系统单元的耦合度：如果一个方法可以用简单的“动词+名词”的形式来命名（例如，loadFile()、getName()），或者如果一个类可以用准确的名词来命名（例如，Employee、Student），那么这样的类或者方法就是内聚度较高的系统单元；反之，如果类或者方法的名字必须包含“和”、“或”等字样才能准确反映其功能特性的话，这些类或方法的内聚度就一定不高
- **耦合度：在前一章我们已经学习了类和类之间的继承和关联关系。耦合度表示类之间关系的紧密程度。耦合度决定了变更一个应用程序的容易程度**。在紧密耦合的类结构中，更改一个类会导致其它的类也随之需要做出修改。显然，这是我们在类设计时应该避免的，因为微小的修改会迅速波动影响到整个应用程序。此外，找到需要修改的所有的地方是必须的，实际上就使得修改变得困难并且耗费时间。而在松散耦合的系统中，我们可以更改一个类，不需要修改其它类，而应用程序仍然能够正常工作

- **概括起来，较低的耦合度和较高的内聚度，也即我们常说的“高内聚、低耦合”是所有优秀软件的共同特征**
- 那么，在面向对象的软件设计时，如何做到高内聚、低耦合呢？这就需要我们在设计时遵循一定的设计原则

- 面向对象软件设计大师们在长期的软件设计实践中，**总结出七条软件设计的基本原则，包括：单一职责、开闭原则、里氏替换原则、依赖倒转原则、接口隔离原则、组合/聚合复用原则、迪米特法则。**遵循这七条原则来设计类，将提高软件系统的质量，做到高内聚、低耦合，从而实现较高可扩展性、可复用性、可维护性。这些面向对象的设计原则是面向对象设计的基本指导思想。下表列出了这些面向对象设计原则的概念以及相对重要性

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/v2-004a5d0def0e42b7cc9913ad9511cc3c_720w.jpg" alt="img" style="zoom:90%;" />
</div>

- 这些设计原则并不是孤立存在的，它们相互依赖，相互补充。

- 概括地讲，面向对象设计原则仍然是面向对象思想的体现。例如，**单一职责原则与接口隔离原则体现了封装的思想；开放封闭原则体现了对象的封装与多态；里氏替换原则是对对象继承的规范；至于依赖倒转原则，则是多态与抽象思想的体现**。在充分理解面向对象思想的基础上，掌握基本的设计原则，并能够在项目设计中灵活运用这些原则，就能够改善我们的设计，尤其能够保证可重用性、可维护性与可扩展性等系统的质量属性。这些核心要素与设计原则，就是我们设计的对象法则，它们是理解和掌握后面我们将要学习的设计模式的必备知识

- **下面是对上述每种设计原则的详细讲解：**

##### **1、单一职责原则**

- 单一职责原则（Single Responsibility Principle，SRP）是指：所有的对象都应该有单一的职责，它提供的所有的服务也都仅围绕着这个职责。换句话说就是：一个类而言，应该仅有一个引起它变化的原因，永远不要让一个类存在多个改变的理由

- 要理解单一职责原则，首先我们要理解什么是类的职责。类的职责是由该类的对象在系统中的角色所决定的。举例来讲，教学管理系统中，老师就代表着一种角色，这个角色决定老师的职责就是教学。而要完成教学的职责，老师需要讲课、批改作业，而讲课、批改作业的行为就相当于我们在程序中类的方法，类的方法和属性就是为了完成这个职责而设置的

- **类的单一职责是说一个类应该只做一件事情**。如果类中某个方法或属性与它所要完成的职责无关，或是为了完成另外的职责，那么这样的设计就不符合类的单一职责原则。而这样的设计的缺点是降低了类的内聚性，增强了类的耦合性。由此带来的问题是当我们使用这个类时，会把原本不需要的功能也带到了代码中，从而造成冗余代码或代码的浪费

- 例如，考虑下图所示的设计。Rectangle（矩形）类有两个方法，方法draw()用于在屏幕上绘制一个矩形，方法area()用于计算矩形的面积。有两个不同的应用程序都要使用Rectangle类，一个是几何计算系统，Rectangle类会在几何形状计算方面为它提供帮助；一个是绘图系统，它需要使用Rectangle类在屏幕上绘制矩形

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/image-20211012162841531.png" alt="img" style="zoom:80%;" />
</div>

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/image-20230511111838502.png" alt="img" style="zoom:70%;" />
</div>

- 这种设计违反了单一职责原则，因为Rectangle类具有两个职责：一个职责提供画矩形几何图形的功能，一个职责提供了计算矩形面积的功能

- 违反单一职责原则会导致一些严重的问题。首先，因为几何计算系统要使用Rectangle类，而Rectangle类又要使用GUI包。所以，在部署安装几何计算系统时，我们必须将GUI包中的类代码一起部署安装。其次，如果因为某些原因，绘图系统的改变导致了Rectangle类的改变，那么这个改变就强迫我们重新构建、测试和部署几何计算系统。如果忘记了这一点，那么几何计算系统可能会以不可预测的方式失败

- 一个较好的设计是把Rectangle类的两个职责分离到下图所示的两个不同的类中，一个类提供计算面积的职责，一个类提供画矩形的职责。现在矩形绘制方式的改变就不会对几何计算系统造成影响

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/image-20230511111902718.png" alt="img" style="zoom:70%;" />
</div>

- 一个类如果有多个职责，也有多个改变它的理由。反之，如果你能想到一个类存在多个使其改变的原因，那么这个类就存在多个职责。例如上面提到的矩形类，要改变图形界面中矩形的外观要改动它，要改变矩形的几何运算也要改到它。因此这个矩形类要被拆成两个

- 单一职责原则提出了对对象职责的一种理想期望。对象不应该承担太多职责，正如人不应该一心分为二用。唯有专注，才能保证对象的高内聚；唯有单一，才能保证对象的细粒度。对象的高内聚与细粒度有利于对象的重用。一个庞大的对象承担了太多的职责，当客户端需要该对象的某一个职责时，就不得不将所有的职责都包含进来，从而造成冗余代码或代码的浪费

- 单一职责原则还有利于对象的稳定。对象的职责总是要提供给其他对象调用，从而形成对象与对象的协作，由此产生对象之间的依赖关系。对象的职责越少，则对象之间的依赖关系就越少，耦合度减弱，受其他对象的约束与牵制就越少，从而保证了系统的可扩展性

- 单一职责原则并不是极端地要求我们只能为对象定义一个职责，而是利用极端的表述方式重点强调：在定义对象职责时，必须考虑职责与对象之间的所属关系。职责必须恰如其分地表现对象的行为，而不至于破坏和谐与平衡的美感，甚至格格不入。换言之，该原则描述的单一职责指的是公开在外的与该对象紧密相关的一组职责。例如，在媒体播放器中，可以在MediaPlayer类中定义一组与媒体播放相关的方法，如Open()、Play()、Stop()等。这些方法从职责的角度来讲，是内聚的，完全符合单一职责原则中“专注于做一件事”的要求。如果需求扩充，需要我们提供上传、下载媒体文件的功能，那么在设计时，就应该定义一个新类如MediaTransfer，由它来承担这一职责；而不是为了方便，草率地将其添加到MediaPlayer类中


##### **2、开闭原则**

- 开闭原则（Open-Close Principle，简称OCP）是指一个软件实体（类、模块、方法等）应该**对扩展开放，对修改关闭**

- 遵循开闭原则设计出来的模块具有两个基本特征：

  - **对于扩展是开放的（Open for extension）：模块的行为可以扩展，当应用的需求改变时，可以对模块进行扩展，以满足新的需求**
  - **对于更改是封闭的（Closed for modification）：对模块行为扩展时，不必改动模块的源代码或二进制代码**

- 这两个特征看起来是相互矛盾的。扩展模块的行为通常需要修改该模块的源代码，而不允许修改的模块通常被认为是具有固定的行为
- 那么，如何在不修改模块源代码的情况下去修改它的行为呢？或者怎样才能在无需对模块进行改动的情况下就改变它的功能呢？

- **实现开闭原则的关键在于抽象化**。在Java中，抽象化的具体实现就是使用抽象类或接口。然而，到底该抽象化什么呢？到底该将什么东西抽象为抽象类或者接口呢？

- 在实际面向对象设计阶段，抽象化可能出现在两种情况下。**一种情况是针对多个领域类的抽象化，一种情况针对单个领域类的抽象化**

- 在面向对象分析阶段，我们得到的领域模型中会存在**多个具有相同行为的领域类**。在设计阶段，我们可以使用抽象类或者接口，将一组对象的共同行为抽象到抽象类或者接口中，而将不同行为的实现封装在子类或者实现类中。**接口或抽象类是不能实例化的，因此对修改就是关闭的；而添加新功能只要实现接口或者继承抽象类，从而实现对扩展开放**
  - 1.使用抽象类。在设计类时，对于拥有共同功能的相似类进行抽象化处理，将公用的功能部分放到抽象类中，而将不同的行为封装在子类中。这样，在需要对系统进行功能扩展时，只需要依据抽象类实现新的子类即可。在扩展子类时，不仅可以拥有抽象类的共有属性和共有方法，还可以拥有自定义的属性和方法
  - 2.使用接口。与抽象类不同，接口只定义实现类应该实现的接口方法，而不实现公有的功能。在现在大多数的软件开发中，都会为实现类定义接口，这样在扩展子类时必须实现该接口。如果要改换原有的实现，只需要改换一个实现类即可

- 比如开发一个发工资程序。老板要为公司中的年薪制员工（用Salary类表示）、按小时付费员工（用Hourly类表示）、合同工（用Contractor类表示）发工资，还要为他们邮寄支票。不同类型的员工薪酬计算的方法有所不同。通过面向对象分析技术，分析上面问题域中的名词，我们很容易得到Boss、Salary、Hourly、Contractor几个领域类

- 根据开闭原则，为了实现对修改关闭，对扩展开放，我们设计出一个抽象类Employee，将Salary类、Hourly类和Contractor类共有的行为（邮寄支票mailCheck()）放在该抽象类中，将不同的行为（计算薪酬computePay()）在Employee中用抽象方法定义，具体的实现放到Employee的子类Salary、Hourly和Contractor中，其设计类图下图所示

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/image-20211012164510882.png" alt="img" style="zoom:90%;" />
</div>

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/v2-ae1f763c68ea87d13d5f8df91c27aed6_720w.jpg" alt="img" style="zoom:90%;" />
</div>


- 于是，Boss类就依赖于抽象类Employee，而不依赖于具体的实现类Salary、Hourly、Contractor等
  - 当添加新的员工类型，出现新的子类时，或者薪酬计算方式变更时，Boss类的代码就不会受到影响，从而实现对修改关闭。同时，具体的子类可以完全替换抽象父类Employee的行为
  - 当新添加一个员工类型时，不会对Boss类的代码产生任何影响，从而实现了对扩展开放

- **使用抽象化技术的另一种情况是针对单个领域类**，将单个领域类中可能会发生变化的行为进行封装，也就是找出类中可能需要变化之处，把它们封装成抽象类或者接口，从而将变化点与不需要变化的代码分离。如果每次新的需求一来，都会使一个领域类的某个行为的代码发生变化，那么我们就可以确定，这部分的代码需要被抽象出来，和其它稳定的代码有所区分。把会变化的部分取出并封装出抽象类或接口，以便以后可以轻易地改动或扩充此部分，而不会影响不需要变化的其它部分。封装变化点的好处在于，将类中经常变化的部分和稳定的部分隔离，有助于增加复用性，并降低系统耦合度

- 例如，假如我们从分析阶段得到一个领域类Guitarist代表吉他演奏家。吉他演奏家的行为包括可以挑选演奏的曲目（setupMusic），可以对吉他校音（tuneInstrument），可以演奏曲目（play），类图下图所示

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/v2-aa324999a8b19e6309bfecbf6e332d02_720w.jpg" alt="img" style="zoom:50%;" />
</div>


- 对于Guitarist类来说，setupMusic() 和 tuneInstrument() 相当稳定，但是play()方法却并非稳定的。一首歌曲可以有几种不同的演奏风格：古典风格、民谣风格、佛拉明戈风格、摇滚风格等。这就意味着根据演奏风格的不同，play()方法有所不同。因为根据演奏风格，类的行为会有所改变，我们就需要将这个行为抽象出来，将它封装到另一个类中。下图是封装并隔离变化点后的类图

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/v2-abf1703c5cfed5220524090d14d4e24c_720w.jpg" alt="img" style="zoom:90%;" />
</div>


- 这里，我们在Guitarist类和GuitarStyle抽象类之间使用了关联，这就允许Guitarist使用继承自抽象类GuitarStyle的具体类。我们已经将play()方法抽象出并封装到另一个类中，这样就将肯定会改变的演奏方式行为与Guitarist类的其它稳定行为隔离了。通过封装变化点，将肯定要发生变化的内容（演奏风格）抽象出来成为一个单独的类，从而实现了对修改关闭，对扩展开放

- 开闭原则是面向对象设计的核心所在。遵循这个原则可以带来灵活性、可重用性和可维护性。其它设计原则（里氏替换原则、依赖倒转原则、组合/聚合复用原则、迪米特法则、接口隔离原则）是实现开闭原则的手段和工具

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/image-20211012181932191.png" alt="img" style="zoom:90%;" />
</div>


##### **3、里氏替换原则**

- 在Java中，支持抽象和多态的关键机制之一是继承。正是使用了继承，我们才可以创建实现父类中抽象方法的子类。那么，是什么规则在支配着这种特殊的继承用法呢？最佳的继承层次的特征又是什么呢？在什么情况下会使我们创建的类层次结构掉进不符合开闭原则的陷阱中呢？这就是里氏替换原则要解决的问题

- 里氏替换原则（The Liskov Substitution Principle，LSP）是由Barbara Liskov女士于1988年提出的，其定义为：“如果对于类型S的每个对象O1存在类型T的对象O2，那么对于所有定义了T的程序P来说，当用O1替换 O2并且S是T的子类型时，P的行为不会改变”。通俗地讲，就是：在一个软件系统中，子类应该能够完全替换任何父类能够出现的地方，并且经过替换后，不会让调用父类的客户程序从行为上有任何改变

- 里氏替换原则是使代码符合开闭原则的一个重要的保证，同时，它体现了：

  - **Ø 类的继承原则：**里氏替换原则常用来检查两个类是否为继承关系。在符合里氏替换原则的继承关系中，使用父类代码的地方，用子类代码替换后，能够正确的执行动作处理。换句话说，如果子类替换了父类后，不能够正确执行动作，那么他们的继承关系就是不正确的，应该重新设计它们之间的关系

  - **Ø 动作正确性保证：**里氏替换原则对子类进行了约束，所以在为已存在的类进行扩展，来创建一个新的子类时，符合里氏替换原则的扩展不会给已有的系统引入新的错误

- 下面我们用示例来阐述。 “正方形不是长方形”是一个理解里氏替换原则的最经典的例子。在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统中，让正方形继承自长方形是顺利成章的事情，于是我们有了如下图所示的设计。

<div align=left>
<img src="{{site.url}}/assets/img/Skill_Category/UML/UML笔记/v2-b044af297f87e353131edd24f0b7bd2b_720w.jpg" alt="img" style="zoom:90%;" />
</div>


- 代码清单1列出了长方形类Rectangle的实现代码

```java
/*代码清单1 Rectangle.java
 * 矩形类的实现代码，用于演示LSP
 */
package ch02.LSP;

public class Rectangle {
  private double length;
  private double width;
  public double getLength() {
    return length;
  }

  public void setLength(double length) {
    this.length = length;
  }

  public double getWidth() {
    return width;
  }

  public void setWidth(double width) {
    this.width = width;
  }
}
```

- 代码清单2列出了正方形类Square的实现代码

```java
/*代码清单2 Square.java
 * 正方形的实现代码，用于演示LSP
 */
package ch02.LSP;

public class Square extends Rectangle {
  public void setWidth(double width) {
    super.setLength(width);
    super.setWidth(width);
  }

  public void setLength(double length) {
    super.setLength(length);
    super.setWidth(length);
  }
}
```

- 假如已有的系统中有代码清单3所示的业务逻辑：长乘以宽必须等于20。当我们使用父类Rectangle调用该业务逻辑时，代码能顺利通过。

```java
/*代码清单3 TestRect.java
 * 测试程序，用于演示LSP
 */
package ch02.LSP;

public class TestRect {
  public static void main(String[] args) {
    TestRect tr = new TestRect();
    Rectangle r = new Rectangle();
    tr.g(r);
  }

  public void g(Rectangle r) {
    r.setWidth(5);
    r.setLength(4);
    if (r.getWidth()*r.getLength()!=20) {
      throw new RuntimeException();
    }
  }
}
```

如果我们将代码清单3的第8、9行替换成如下代码，使用子类Square替换父类Rectangle，调用相同的业务逻辑，运行时就会抛出一个RuntimeException异常。

```java
Rectangle s = new Square();
tr.g(s);
```

由此，我们得出结论：父类Rectangle不能被子类Square替换，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏替换原则，它们之间的继承关系不成立，正方形不是长方形。（**注意：这里的错误并不是说继承有问题，而是不同类型时候计算不一样导致的问题！**）

“正方形不是长方形”，正方形是长方形也不是长方形，这样结论似乎就是个悖论。产生这种混乱的原因有两个：

- **原因一：对类的继承关系的定义没有搞清楚。**

面向对象的设计关注的是对象的行为，它是使用“行为”来对对象进行分类的，只有行为一致的对象才能抽象出一个类来。我们说类的继承关系就是一种“is-a”关系，实际上指的是行为上的“is-a”关系，可以把它描述为“表现为，act as”。

正方形在设置长度和宽度这两个行为上，与长方形显然是不同的。长方形的行为：设置长方形的长度的时候，它的宽度保持不变，设置宽度的时候，长度保持不变。正方形的行为：设置正方形的长度的时候，宽度随之改变；设置宽度的时候，长度随之改变。所以，如果我们把这种行为加到父类长方形的时候，就导致了正方形无法继承这种行为。我们“强行”把正方形从长方形继承过来，就造成无法达到预期的结果。

- **原因二：设计要依赖于用户需求和具体环境。**

继承关系要求子类要具有基类全部的行为。这里的行为是指落在需求范围内的行为。

这里我们以另一个理解里氏替换原则的经典例子“鸵鸟非鸟”来做示例。生物学中对于鸟类的定义是“恒温动物，卵生，全身披有羽毛，身体呈流线形，有角质的喙，眼在头的两侧。前肢退化成翼，后肢有鳞状外皮，有四趾”。从生物学角度来看，鸵鸟肯定是一种鸟，是一种继承关系。但是根据上一个“正方形非长方形”的例子，鸵鸟和鸟之间的继承关系又可能不成立。那么，鸵鸟和鸟之间到底是不是继承关系如何判断呢？这需要根据用户需求来判断。

现在鸟类有四个对外的行为，其中两个行为分别落在A和B系统需求中，如下图所示。

<img src="UML笔记.assets/v2-3814ab2e16f89b94dc06980a695e6f32_720w.jpg" alt="img" style="zoom: 50%;" />



A需求期望鸟类提供与飞翔有关的行为，即使鸵鸟跟普通的鸟在外观上就是100%的相像，但在A需求范围内，鸵鸟在飞翔这一点上跟其它普通的鸟是不一致的，它没有这个能力，所以，鸵鸟类无法从鸟类派生，鸵鸟不是鸟。

B需求期望鸟类提供与羽毛有关的行为，那么鸵鸟在这一点上跟其它普通的鸟一致的。虽然它不会飞，但是这一点不在B需求范围内，所以，它具备了鸟类全部的行为特征，鸵鸟类就能够从鸟类派生，鸵鸟就是鸟。

所有子类的行为功能必须和使用者对其父类的期望保持一致，如果子类达不到这一点，那么必然违反里氏替换原则。在实际的开发过程中，不正确地滥用继承关系是非常有害的。伴随着软件开发规模的扩大，参与的开发人员也越来越多，每个人都在使用别人提供的组件，也会为别人提供组件。最终，所有人的开发的组件经过层层包装和不断组合，被集成为一个完整的系统。每个开发人员在使用别人的组件时，只需知道组件的对外裸露的接口，那就是它全部行为的集合，至于内部到底是怎么实现的，无法知道，也无须知道。所以，对于使用者而言，它只能通过接口实现自己的预期，如果组件接口提供的行为与使用者的预期不符，错误便产生了。里氏替换原则就是在设计时避免出现子类与父类不一致的行为。

里氏替换原则目的就是要保证继承关系的正确性。那么，对于违反里氏替换原则的继承关系，我们该如何修正呢？

如果父类A和子类B之间的关系违反了里氏替换原则，那么A和B就不适合设计为继承关系。我们就要重新设计二者之间的关系。设计方案有两种，需要根据具体情况进行选择：

- **创建一个新的抽象类或者接口，作为两个具体类的基类。将具体类A和B的共同行为转移到C中，从而解决A和B行为不一致的问题。**
- **将B到A的继承关系改为委托关系。具体参考组合/聚合复用原则。**

对于“正方形非长方形”问题，既然二者之间的继承关系违反了里氏替换原则，我们就应该重新设计二者之间的关系。我们可以采用第一种方案，正方形和长方形的共同行为（getLength()、getWidth()方法）抽象并封装转移到一个抽象类或者接口中，比如一个“四方形”接口或者抽象类，然后让正方形和长方形分别实现四方形接口或者继承四方形抽象类，如下图所示。

<img src="UML笔记.assets/v2-5f725aa53a3cd4bc8b04b1aaebb8050f_720w.jpg" alt="img" style="zoom: 80%;" />



一般来说，只要有可能，就不要从具体类继承。如图2.9所示的类图就给出了一个继承形成的等级结构的典型例子。从图可以看出，所有的继承都是从抽象类开始，而所有的具体类都没有子类。也就是说，在一个由继承关系形成的等级结构中，**树叶节点都应当是具体类，树枝节点都应该是抽象类或者接口。**

<img src="UML笔记.assets/v2-faf6b489a1f44558041302b19846718b_720w.jpg" alt="img" style="zoom: 40%;" />



里氏替换原则实现了开闭原则中的对扩展开放。实现开闭原则的关键步骤是抽象化，父类与子类之间的继承关系就是一种抽象化的体现。因此，**里氏替换原则是实现抽象化的一种规范。只要能做到子类可以完全替代其父类的行为，那么新增加的具体子类在重写父类的行为时，不会对客户代码产生任何不良的影响（即保证原来的抽象类仍代表父集合的共性），从而实现对扩展开放**。违反里氏替换原则意味着违反了开闭原则，反之未必。里氏替换原则是使代码符合开闭原则的一个重要保证。

<img src="UML笔记.assets/image-20211012191216899.png" alt="image-20211012191216899" style="zoom: 80%;" />

---



#### 4、依赖倒转原则



依赖倒转原则（Dependency Inversion Principle，简称DIP）是指将两个模块之间的依赖关系倒置为依赖抽象类或接口。具体有两层含义：

- 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
- 抽象不应该依赖于细节，细节应该依赖于抽象。

依赖倒转原则用于指导我们如何正确地消除模块间的依赖关系，同时它也是我们以后要学习到的Spring、Hibernate等JavaEE框架设计的核心原则。

所谓依赖是指如果一个模块A使用另一个模块B，我们称模块A依赖模块B。在应用程序中，有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；另外，有一些高层次的类，这些类封装了某些复杂的逻辑，这些类我们称之为高层模块。高层次模块要完成自己封装的功能，就必须要使用低层模块，于是高层模块就依赖于低层模块。

高层模块依赖于低层模块的现象，在传统的结构化程序设计中，是非常常见的。因为结构化程序设计就是采用由上到下、逐层分解的策略，把大型和复杂的软件系统分解成若干个人们易于理解和易于分析的子系统。这里的分解是根据软件系统的逻辑特性和系统内部各成分之间的逻辑关系进行的。在分解过程中，被分解的上层就是下层的抽象，下层为上层的具体细节。这样，就造成高层抽象模块依赖低层模块；抽象层依赖具体层。但在实际系统中，抽象层是相对稳定的，而低层模块却是经常变动的。因为高层模块依赖于低层模块，一旦低层模块发生改变，高层模块也会受到影响。为了保持系统的稳定，应该使低层模块依赖于高层模块。因此，结构化程序设计的方法是不正确的。

那么，如何让低层模块依赖于高层模块呢？我们知道，高层模块肯定要使用低层模块提供的服务，不可能不让二者之间完全不存在依赖关系。但是，在面向对象设计中，类和类之间依赖关系可以分为两种类型：

- **具体耦合关系：发生在两个具体的（可实例化的）类之间，经由一个类对另一个具体类的直接引用造成。**
- **抽象耦合关系：发生在一个具体类和一个抽象类（或接口）之间，使两个必须发生关系的类之间存有最大的灵活性。**

如果高层模块直接调用低层模块提供的服务，那么就是具体耦合关系，这样高层模块依赖于低层模块就不可避免。但是，如果我们使用抽象耦合关系，在高层模块和低层模块之间定义一个抽象接口，高层模块调用抽象接口定义的方法，低层模块实现该接口。这样，就消除了高层模块和低层模块之间的直接依赖关系。现在，高层模块就不依赖于低层模块了，二者都依赖于抽象。同时也实现了“抽象不应该依赖于细节，细节应该依赖于抽象”。

**依赖倒转原则的本质就是要求将类之间的关系建立在抽象接口的基础上的**。通过上面的方式，将错误的依赖关系倒转过来，使具体实现类依赖于抽象类和接口。这就是依赖倒转原则中“倒转”的由来。

以抽象方式耦合是依赖倒转原则的关键。抽象耦合关系总要涉及具体类从抽象类继承，并且需要保证在任何引用到基类的地方都可以改换成其子类，**因此，里氏替换原则是依赖倒转原则的基础。**

依赖倒转原则带来的一个启示是：针对接口编程，而不是针对实现编程。也就是说，当客户要使用一个接口的实现类功能时，应该针对定义这些功能的接口编程，而不是针对该接口的实现类编程。

例如，假如我们需要开发一个程序描述不同类型的几何图形，并计算这些几何图形的面积和周长。我们知道，不同的几何图形计算周长和面积的方法不一样。根据开闭原则，我们应该封装变化点，把要变化的部分封装起来。于是，很容易得到一个设计：用类Point代表一个点，用接口Shape定义所有几何图形的共同特征——面积和周长，如果要创建不同的几何图形，就要创建具体类来实现Shape接口。这意味着具体类必须实现Shape接口的所有抽象方法。这样就得到如下图所示的类图。

<img src="UML笔记.assets/v2-fc26c14e3f14a07dd27654d6db7549e5_720w.jpg" alt="img" style="zoom: 40%;" />



到现在为止，我们的设计是满足开闭原则的，没有任何问题。如果要计算各个几何图形的周长和面积，我们可以为每个不同的几何形状编写一个单独的应用程序，在应用程序中使用几何图形的具体实现类，如下图所示。



<img src="UML笔记.assets/v2-ebb0150d776b35f4f298f21429847e3e_720w.jpg" alt="img" style="zoom:80%;" />



**这样做有什么问题呢？很显然，我们写了三个不同的程序做同一件事情。如果要添加另一个几何图形，比如菱形（Rhombic），就必须编写两个新的类，一个实现Shape接口的Rhombus类，一个RhombusApp类。这样做效率显然很低，也违反了依赖倒转原则（高层模块RectangleApp等依赖于低层模块Rectangle）。**

那么我们如何纠正呢？回忆我们在Java面向对象编程中所学的多态机制，我们完全可以面向父类型——接口编程，执行时候根据动态绑定机制，动态决定执行哪个具体类的方法。

在计算几何图形周长和面积的应用中，既然已经有了很多实现Shape接口的几何图形类，我们就可以只创建一个程序，完成所有几何图形周长和面积的计算。代码清单4所示的ShapeTest程序演示了这种面向接口编程的方法，在程序的main()方法中创建一个Shape类型的集合，用不同的几何形状填充集合，然后对集合进行遍历，计算周长和面积。

```java
/*代码清单4 ShapeTest.java
 * 演示面向接口编程
 */
package ch02;
import java.util.*; 
public class ShapeTest { 
public static void main(String [] args)     { 
    List<Shape> figures = new ArrayList<Shape>(); 
    
    figures.add(new Rectangle(10, 20)); 
    figures.add(new Circle(10)); 

    Point p1 = new Point(0.0, 0.0);
    Point p2 = new Point(5.0, 1.0); 
    Point p3 = new Point(2.0, 8.0); 
    figures.add(new Triangle(p1, p2, p3)); 
    
    Iterator<Shape> iter = figures.iterator(); 
    
    while (iter.hasNext()) { 
      Shape nxt =  iter.next(); 
      System.out.printf("面积 = %8.4f 周长= %8.4f\n",
      nxt.computeArea(), nxt.computePerimeter()); 
    } 
  } 
} 
```



**在上述代码中，我们面向接口而不是面向实现编程，针对接口Shape编程，而不是针对接口的具体实现类Circle、Rectangle、Triangle等编程，程序的灵活性、可扩展性更强。**

依赖倒转原则实现了开闭原则中对变更封闭。因为客户代码依赖于抽象类或者接口，而非具体类。抽象类或者接口代表了父集合的共性，它通常是比较稳定的（不会变化），因而可以在具体子类变化时，保证客户代码不受影响，从而实现对变更封闭。

<img src="UML笔记.assets/image-20211013100712743.png" alt="image-20211013100712743" style="zoom:80%;" />

---



#### 5、组合/聚合复用原则



组合/聚合复用原则（Composite/Aggregation Reuse Principle，CARP）是指要尽量使用组合/聚合而非继承来达到复用目的。另一种解释是在一个新的对象中使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象委托功能达到复用这些对象的目的。

在面向对象的设计中，有两种方法可以实现对已有对象重用的目的，即通过组合/聚合，或者通过继承。那么，这两种不同的复用方式在可维护性方面有什么区别呢？



**1）组合/聚合复用**

我们知道组合/聚合都是关联关系的特殊种类，二者都是体现整体与部分的关系，也就是两个类之间的是“has-a”关系，它表示某一个角色具有某一项责任。由于组合/聚合都可以将已有的对象加入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，从而实现对象复用。

例如，一台计算机，是由CPU、内存、输入设备、输出设备和外存等组装而成。计算机对象为整体，CPU、内存、输入设备、输出设备和外存等为部分，它们是聚合关系。如果一台计算机没有打印功能，可以加入一个打印机，使打印机成为计算机的一部分，从而重用打印机的打印功能。换一种角度来看，如果需要计算机有打印的责任，那么就可以将该责任委托给作为部分的打印机。

**使用组合/聚合实现复用有如下好处：**

- 新对象存取成分对象的唯一方法是通过成分对象的接口。
- 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的。
- 这种复用所需的依赖较少。
- 每一个新的类可以将焦点集中在一个任务上。
- 这种复用可以在运行时间内动态进行，作为整体的新对象可以动态地引用与部分对象类型相同的对象。**也就是说，组合/聚合是动态行为，即运行时行为。可以通过使用组合/聚合的方式在设计上获得更高的灵活性。**

- 当然，这种复用也有缺点。其中最主要的缺点就是系统中会有较多的对象需要管理。
- 一般来说，如果一个角色得到了更多的责任，就可以使用组合/聚合关系将新的责任委派到合适的对象上。



**2）继承复用**

继承是面向对象语言特有的复用工具。由于使用继承关系时，新的实现较为容易，因父类的大部分功能可以通过继承的关系自动进入子类；同时，修改和扩展继承而来的实现较为容易。于是，在面向对象设计理论的早期，程序设计师十分热衷于继承，好像继承就是最好的复用手段，于是继承也成为了最容易被滥用的复用工具。然而，**继承有多个缺点：**

- 继承复用破坏封装，因为继承将父类的实现细节暴露给子类。由于父类的内部细节常常是对于子类透明的，所以这种复用是透明的复用，又称“白箱”复用。
- 如果父类发生改变，那么子类的实现也不得不发生改变。
- 从父类继承而来的实现是静态的，也就是编译时行为，不可能在运行时间内发生改变，没有足够的灵活性。

**正是因为继承有上述缺点，所以应首先使用组合/聚合，其次才考虑继承，达到复用的目的。并且在使用继承时，要严格遵循里氏替换原则。有效地使用继承会有助于对问题的理解，降低复杂度，而滥用继承会增加系统构建、维护时的难度及系统的复杂度。**

**要正确的选择组合/聚合和继承，必须透彻的理解里氏替换原则和Coad法则**。里氏替换原则前面学习过，Coad法则由Peter Coad提出，总结了一些什么时候使用继承作为复用工具的条件。只有当以下的Coad条件全部被满足时，才应当使用继承关系：

- 子类是父类的一个特殊种类，而不是父类的一个角色，也就是区分“has-a”和“is-a”。**只有“is-a”关系才符合继承关系，“has-a”关系应当用组合/聚合来描述。**
- 永远不会出现需要将子类换成另外一个类的子类的情况。如果不能肯定将来是否会变成另外一个子类的话，就不要使用继承。
- 子类具有扩展父类的责任，而不是具有置换（重写）或注销掉父类的责任。如果一个子类需要大量的置换掉父类的行为，那么这个类就不应该是这个父类的子类。
- 只有在分类学角度上有意义时，才可以使用继承。不要从工具类继承。

错误的使用继承而不是组合/聚合的一个常见原因是错误的把“has-a”当成了“is-a”。

- “is-a”代表一个类是另外一个类的一种；
- “has-a”代表一个类是另外一个类的一个角色，而不是另外一个类的特殊种类。

我们看一个例子。如果我们把“人”当成一个类，然后把“雇员”、“经理”、“学生”当成是“人”的子类，如下图所示。这种设计的错误在于把“角色”的等级结构和“人”的等级结构混淆了。“经理”、“雇员”、“学生”是一个人的角色，一个人可以同时拥有上述角色。如果按继承来设计，那么如果一个人是雇员的话，就不可能是经理，也不可能是学生，这显然不合理。



<img src="UML笔记.assets/v2-007cb63470db36d0ea61c5742c84b38a_720w.jpg" alt="img" style="zoom: 50%;" />



正确的设计是有个抽象类“角色”，“人”可以拥有多个“角色”（聚合），“雇员”、“经理”、“学生”是“角色”的子类，如下图所示。



<img src="UML笔记.assets/v2-97ecf217d27d03b50c2b8eeec853053c_720w.jpg" alt="img" style="zoom:50%;" />



此外，只有两个类满足里氏替换原则的时候，才可能是“is-a”关系。也就是说，如果两个类是“has-a”关系，但是设计成了继承，那么肯定违反里氏替换原则。

-----



#### 6、接口隔离原则



通过对前面几个设计原则的讨论，我们会发现接口是一个好东西，因为使用接口，可以使代码灵活性和可维护性更强。但是，在设计接口时，我们还必须遵循接口隔离原则。

**接口隔离原则（Interface Segregation Principle，简称ISP）是指客户不应该依赖它们用不到的方法，只给每个客户它所需要的接口。换句话说，就是不能强迫用户去依赖那些他们不使用的接口。**

接口隔离原则实际上包含了两层意思：

- **接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里**。如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口，使用多个专门的接口比使用单一的总接口要好。
- 接口的继承原则：如果一个接口A继承另一个接口B，则接口A相当于继承了接口B的方法，那么继承了接口B后的接口A也应该遵循上述原则：不应该包含用户不使用的方法。反之，则说明接口A被B给污染了，应该重新设计它们的关系。

如果用户被迫依赖他们不使用的接口，当接口发生改变时，他们也不得不跟着改变。换而言之，一个用户依赖了未使用但被其他用户使用的接口，当其他用户修改该接口时，依赖该接口的所有用户都将受到影响。这显然违反了开闭原则，也不是我们所期望的。

下面我们举例说明怎么设计接口或类之间的关系，使其不违反ISP原则。

假如有一个门（Door），有锁门（lock）和开锁（unlock）功能。此外，可以在门上安装一个报警器而使其具有报警（alarm）功能。用户可以选择一般的门，也可以选择具有报警功能的门。分析需求，找出其中的名词，我们不难得到三个候选类：门（Door）、普通门（CommonDoor）、有报警功能的门（AlarmDoor）。我们该如何设计这三个候选类之间的关系呢？

最简单的设计就是将Door作为接口，在Door接口里定义所有的方法，让CommonDoor和AlarmDoor作为该接口的实现类，从而强制这两个类实现Door接口中的所有方法，如下所示。但这样一来，依赖Door接口的CommonDoor却不得不实现未使用的alarm()方法。很显然，这个Door接口有点肥胖，内聚性太差，违反了接口隔离原则。

<img src="UML笔记.assets/v2-72b64a8bcf2888a9e3f697ecbb7a76b3_720w.jpg" alt="img" style="zoom:50%;" />

​                      **太肥胖的接口**



那么，好吧，将报警功能从Door中分离出来，封装成一个Alarm接口。在Alarm接口定义alarm()方法，在Door接口定义lock()和unlock()方法，Door接口继承Alarm接口，如下图所示。现在一个接口根据功能分成了两个接口，貌似设计要更好一些。但是，可惜的是：跟第一种方法一样，依赖Door接口的CommonDoor却不得不实现未使用的alarm()方法，也就是说接口Door被接口Alarm“污染”了，这种设计同样违反了接口隔离原则。

<img src="UML笔记.assets/v2-ea7a79989aabea64cecbf33359a4ea3d_720w.jpg" alt="img" style="zoom:50%;" />

​                           **接口污染**



很显然，太肥胖的接口以及接口污染都会造成用户依赖于他们不用的方法，从而违反了接口隔离原则。我们不应该强迫用户依赖于他们不用的方法。那么，到底如何做才能实现这一点呢？有两种方式：

- **通过多重继承分离接口。多重继承可以有两个方式，第一种方式是同时实现两个接口，属于多重接口继承；第二种方式是实现一个接口，同时继承一个具体类，实际上也是一种多重继承**。现在我们继续本例的设计，这次我们为了避免太肥胖的接口以及接口污染，我们在Alarm接口中定义alarm()方法，在Door接口中定义lock()和unlock()方法，这两个接口之间无继承关系。CommonDoor实现Door接口。而AlarmDoor根据多重继承的实现方式，分为两种方案。



第一种方案为：AlarmDoor类同时实现Door和Alarm接口，如下图所示。

- **通过多重继承分离接口方式一**

<img src="UML笔记.assets/v2-eb4ab2fa27fd9e1fe3871c66438d75f0_720w.jpg" alt="img" style="zoom:55%;" />

<img src="UML笔记.assets/image-20211013113128824.png" alt="image-20211013113128824" style="zoom:80%;" />

第二种方案为：继承CommonDoor，并实现Alarm接口，如下图所示。这两种设计方案都将Door接口和Alarm接口分离了，避免了肥胖的接口和接口污染，都遵循了接口隔离原则，但是第二种方案更具有实用性。

- **通过多重继承分离接口方式二**

<img src="UML笔记.assets/v2-54754ce7b13b4ddcf436c4e1a6472bb0_720w.jpg" alt="img" style="zoom:50%;" />

<img src="UML笔记.assets/image-20211013114254391.png" alt="image-20211013114254391" style="zoom:80%;" />

第三种方案为：通过委托分离接口。在这种方法里，AlarmDoor实现了Alarm接口，同时把功能lock和unlock委托给CommonDoor对象完成。这种设计遵循了接口隔离原则。实际上，这种方法是对第三种方法的第二个方案应用了组合/聚合复用原则，将AlarmDoor和CommonDoor的继承关系转换为聚合关系。

- **通过委托分离接口**

<img src="UML笔记.assets/v2-b984d90b279da153414b3d42b1b7617b_720w.jpg" alt="img" style="zoom:60%;" />



<img src="UML笔记.assets/image-20211013114940995.png" alt="image-20211013114940995" style="zoom:80%;" />

接口隔离原则从对接口的使用上，为我们对接口抽象的颗粒度建立了判断基准：在为系统设计接口的时候，使用多个专门的接口代替单一的胖接口。

---



#### 7、迪米特法则



我们知道，面向对象的系统是由很多对象组成的，对象和对象之间交互，形成了整个系统。既然对象和对象之间存在交互，那么对象和对象之间就必然存在一定依赖关系。依赖即耦合，太多的类耦合在一起相互依赖，就会导致系统的可维护性变得糟糕起来。那么，如何才能避免这种情况呢？这就要求我们在设计中处理类和类之间的交互时，遵循迪米特法则。

迪米特法则（Law of Demeter，简称LOD），又称为“最少知识原则”，它的定义为：一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易。迪米特法则是对软件实体之间通信的限制，它对软件实体之间通信的宽度和深度做出了要求。迪米特的其它表述方式为：

1. 只与你直接的朋友们通信。
2. 不要跟“陌生人”说话。
3. 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

例如，军队里面有元帅、军官和士兵，元帅认识军官，军官认识自己管辖的士兵。元帅要攻击敌军，他不必直接对士兵下命令，只需要下命令给自己认识的军官，由军官将指令转发给自己所辖士兵即可。用迪米特法则解释，元帅和军官、军官和士兵是“朋友”，元帅和士兵是“陌生人”，元帅只应该与自己直接的“朋友”——军官说话，不要跟“陌生人”——士兵说话。

那么，如何界定朋友圈和陌生人呢？迪米特法则指出，做为“朋友”的条件为：

1. **当前对象本身（this）；**
2. **被当做当前对象的方法的参数传入进来的对象；**
3. **当前对象的方法所创建或者实例化的任何对象；**
4. **当前对象的任何组件（被当前对象的实例变量引用的任何对象）。**

任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”。

迪米特法则指出：就任何对象而言，在该对象的方法内，我们只应该调用属于上述“朋友圈”对象的方法。也就是说：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。不要同陌生人说话，也就是不要调用陌生人的方法。

- 代码清单5是一个汽车类，展示遵循迪米特法则来调用方法的各种做法。

```java
/*代码清单2.5 ShapeTest.java
 * 演示面向接口编程
 */

public class Car { 
  Engine engine;   //这是类的一个组件，我们能够调用它的方法。
  
  public void start(Key key) {  //做为参数传递进来的对象key，其方法可以被调用
    Doors doors = new Doors();   在方法中创建了一个新的对象，其方法可以被调用

    boolean authorized = key.turns();   //调用被当作参数传递进来的对象的方法

    if (authorized) {
      engine.start();    //调用对象组件的方法
      updateDashboardDisplay();    //调用同一对象内的本地方法
      doors.lock();           //可以调用创建或实例化的对象的方法
    }
  }

  public void updateDashboardDisplay() {
    //更新显示
  }
} 
```



迪米特法则是一种面向对象系统设计风格的一种法则，尤其适合做大型复杂系统设计指导原则。但是也会造成系统的不同模块之间的通信效率降低，使系统的不同模块之间不容易协调等缺点。同时，因为迪米特法则要求类与类之间尽量不直接通信，如果类之间需要通信就通过第三方转发的方式，这就直接导致了系统中存在大量的中介类，这些类存在的唯一原因是为了传递类与类之间的相互调用关系，这就毫无疑问的增加了系统的复杂度。解决这个问题的方式是：使用依赖倒转原则，这要就可以是调用方和被调用方之间有了一个抽象层，被调用方在遵循抽象层的前提下就可以自由的变化，此时抽象层成了调用方的朋友。

----

### 结构化绘图

----







---

### 面向对象绘图

---



#### 名词解释



**OO**：Object Oriented,面向对象。基于对象概念，以对象为中心，以类和即成为构造机制，来认识、理解、刻画客观世界和涉及、构建相应的软件系统。

**OOA**：Object-Oriented Analysis,面向对象的分析。是确定需求或者业务的角度，按照面向对象的思想来分析业务。

**OOD**：Object-Oriented Design,面向对象的设计。是处于OOA和OOP之间的一个业务流程，其主要作用主要是对OOA分析的结果做进一步的规范化整理，一边能够被OOP直接应用。

**OOP**：Object Oriented Programming,面向对象的程序设计。简而言之就是在代码层面实现OOA和OOD。



**对象**：是现实世界中实际存在的事物。例如：灰鸭、红头鸭、棉花鸭等。

**属性**：描述对象静态特征的数据项。例如：鸭子的羽毛有灰色、白色、褐色等。

**操作**：描述对象动态特征的一个动作序列。

**类**：具有相同属性和操作的一组对象的集合，也可以说是生成对象的模板。例如：灰鸭、红头鸭、棉花呀都属于鸭类。

**接口**：(interface)在java中是一种抽象类型，是抽象方法的集合，一个抽象类通过继承接口来继承接口里的抽象方法。在实际应用过程中一般是抽象类继承接口，然后是具体类来实现抽象接口。

**封装**：隐藏对象的属性和实现细节，仅仅对外提供接口，控制属性的读和修改的访问级别，来加强程序的安全性。

**继承**：主要是子类继承父类，然后子类拥有父类的属性和方法。

**消息**：向对象发出的服务请求。

**多态**：同一命名可以具有不同的语义。在OO方法中，常指在一般类中定义的属性或者方法被子类继承之后，可以具有不同的数据类型或者是表现出不同的行为。

---

### UML十五种类图

---

<img src="UML笔记.assets/image-20211013144421035.png" alt="img" style="zoom: 60%;" />

![img](UML笔记.assets/v2-ef067b4c79b4b3f38ca2ad69e84f5106_720w.jpg)

---



#### 结构型的图 (Structure Diagram)

---

##### 类图 (Class Diagram)



###### 类图中具体类、抽象、接口和包的表示法

UML类图中具体类、抽象类、接口和包有不同的表示方法。



**1）在UML类图中表示具体类**

具体类在类图中用矩形框表示，矩形框分为三层：第一层是类名字。第二层是类的成员变量；第三层是类的方法。成员变量以及方法前的访问修饰符用符号来表示：

- “+”表示 `public`  对能看到这个类的任何元素都可见
- “-”表示 `private` 对这个类的其他元素可见
- “#”表示 `protected` 对这个类及其子类的其他元素可见
- 不带符号表示 `default` 对同一个包中的其他元素可见

<img src="UML笔记.assets/v2-71b22158f5b09dffa57a123d72ec4653_720w.jpg" alt="img" style="zoom:80%;" />



**2）在UML类图中表示抽象类**

抽象类在UML类图中同样用矩形框表示，但是抽象类的类名以及抽象方法的名字都用斜体字表示，如下图所示。

<img src="UML笔记.assets/v2-5c69cd9ff703377f7bbf37cee8199451_720w.jpg" alt="img" style="zoom:80%;" />



**3）在UML类图中表示接口**

接口在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 <<interface>>表示，下面是接口的名字，第二层是方法，如图3所示。此外，接口还有另一种表示法，俗称棒棒糖表示法，就是类上面的一根棒棒糖（圆圈+实线）。圆圈旁为接口名称，接口方法在实现类中出现。

<img src="UML笔记.assets/v2-e39bdff5514c38e7797848372ac51365_720w.jpg" alt="img" style="zoom:80%;" />



**4）在UML类图中表示包**

类和接口一般都出现在包中，UML类图中包的表示形式如下图所示。

<img src="UML笔记.assets/v2-b421c9c15219feba7dd9cf7681070682_720w.jpg" alt="img" style="zoom:80%;" />



###### 在类图中表示关系

类和类、类和接口、接口和接口之间存在一定关系，UML类图中一般会有连线指明它们之间的关系。关系共有六种类型，**分别是实现关系、泛化关系、关联关系、依赖关系、聚合关系、组合关系**，如图6所示。

<img src="UML笔记.assets/v2-941a070601f399d992125ef31261637e_1440w.jpg" alt="30分钟学会UML类图" style="zoom: 45%;" />



| Type  | Description      | 举例                |
| ----- | ---------------- | ------------------- |
| <\|-- | 继承关系         | classA --\|> classB |
| *--   | 组合关系         | classC --* classD : |
| o--   | 聚合关系         | classE --o classF   |
| -->   | 关联关系（单向） | classG --> classH   |
| --    | 关联关系         | classI -- classJ    |



**1）实现关系**

**实现关系是指接口及其实现类之间的关系**。在UML类图中，实现关系用空心三角和虚线组成的箭头来表示，从实现类指向接口，如下图所示。在Java代码中，实现关系可以直接翻译为关键字 `implements`。

<img src="UML笔记.assets/v2-616c153ec74d496a811ac50c83c3653c_720w.jpg" alt="img" style="zoom:80%;" />



**2）泛化关系**

**泛化关系（Generalization）是指对象与对象之间的继承关系**。如果对象A和对象B之间的“is a”关系成立，那么二者之间就存在继承关系，对象B是父对象，对象A是子对象。例如，一个年薪制员工“is a”员工，很显然年薪制员工Salary对象和员工Employee对象之间存在继承关系，Employee对象是父对象，Salary对象是子对象。

在UML类图中，泛化关系用空心三角和实线组成的箭头表示，从子类指向父类，如下图所示。在Java代码中，对象之间的泛化关系可以直接翻译为关键字 `extends`。

<img src="UML笔记.assets/v2-04064db11797cf36229d67407fea1b83_720w.jpg" alt="img" style="zoom:80%;" />



**3）关联关系**

关联关系（Association）是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。在Java中，关联关系的代码表现形式为一个对象含有另一个对象的引用。也就是说，**如果一个对象的类代码中，包含有另一个对象的引用，那么这两个对象之间就是关联关系。**

**关联关系有单向关联和双向关联**。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。

在UML图中，双向关联关系用带双箭头的实线或者无箭头的实线双线表示。单向关联用一个带箭头的实线表示，箭头指向被关联的对象，如下图所示。这就是导航性（Navigatity）。

<img src="UML笔记.assets/v2-3f331f3dc075abb4215413014688638f_720w.jpg" alt="img" style="zoom:80%;" />

一个对象可以持有其它对象的数组或者集合。在UML中，通过放置多重性（multipicity）表达式在关联线的末端来表示。多重性表达式可以是一个数字、一段范围或者是它们的组合。多重性允许的表达式示例如下：

- 数字：精确的数量
- `*`或者`0..*`：表示0到多个
- `0..1`：表示0或者1个，在Java中经常用一个空引用来实现
- `1..*`：表示1到多个



**关联关系又分为依赖关联、聚合关联和组合关联三种类型。**



**4）依赖关系**

**依赖（Dependency）关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系**。如果对象A依赖于对象B，则 A “use a” B。比如驾驶员和汽车的关系，驾驶员使用汽车，二者之间就是依赖关系。

在UML类图中，依赖关系用一个带虚线的箭头表示，由使用方指向被使用方，表示使用方对象持有被使用方对象的引用，如下图所示。

<img src="UML笔记.assets/v2-431e044bbf26778a20dd788968e22aac_720w.jpg" alt="img" style="zoom:80%;" />

依赖关系在Java中的具体代码表现形式为**B为A的构造器**或**方法中的局部变量**、**方法或构造器的参数**、**方法的返回值**，或者**A调用B的静态方法**。

下面我们用代码清单1和代码清单2所示的Java代码来演示对象和对象之间的依赖关系。

- 代码清单1所示的`B`类定义了一个成员变量 `field1`，一个普通方法 `method1()` 和一个静态方法 `method2()`。

```java
//代码清单1 B.java
public class B {
  public String field1;   //成员变量

  public void method1() {
    System.println("在类B的方法1中");
  }

  public static void method2() {                 //静态方法
    System.out.println("在类B的静态方法2中");
  }
}
```

- 代码清单2所示的`A`类依赖于`B`类，在`A`类中定义了四个方法，分别演示四种依赖形式

```java
/* 代码清单2 A.java
  A依赖于B
*/

public class A {
  public void method1() {
    //A依赖于B的第一种表现形式：B为A的局部变量
    B b = new B();
    b.method1();
  }

  public void method2() {
    //A依赖于B的第二种表现形式： 调用B的静态方法
    B.method2();
  }

  public void method3(B b)  {
    //A依赖于B的第三种表现形式：B作为A的方法参数
    String s = b.field1;
  }

  //A依赖于B的第四种表现形式：B作为A的方法的返回值
  public B method4() {
    return new B();
  }
}
```



**5）聚合关系与组合关系**

**聚合（Aggregation）是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 “has a” 的关系**。（**此时整体与部分之间是可分离的）**，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，**所以聚合关系也常称为共享关系**。例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。

在UML图中，聚合关系用空心菱形加实线箭头表示，空心菱形在整体一方，箭头指向部分一方，如下图所示。

<img src="UML笔记.assets/v2-82cb160ed1566d1d04ea320575b54d5f_720w.jpg" alt="img" style="zoom:80%;" />



**组合（Composition）也是关联关系的一种特例，它同样体现整体与部分间的包含关系，即 “contains a” 的关系**。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。**这种关系比聚合更强**，也称为强聚合。如果`A`组合`B`，则`A`需要知道`B`的生存周期，即可能`A`负责生成或者释放`B`，或者`A`通过某种途径知道`B`的生成和释放。

例如，人包含头、躯干、四肢，它们的生命周期一致。当人出生时，头、躯干、四肢同时诞生。当人死亡时，作为人体组成部分的头、躯干、四肢同时死亡。

在UML图中，组合关系用实心菱形加实线箭头表示，实心菱形在整体一方，箭头指向部分一方，如下图所示。

<img src="UML笔记.assets/v2-e651244eeca9c0881cbdd2add429e850_720w.jpg" alt="img" style="zoom:80%;" />

在Java代码形式上，聚合和组合关系中的部分对象是整体对象的一个成员变量。但是，在实际应用开发时，两个对象之间的关系到底是聚合还是组合，有时候很难区别。在Java中，仅从类代码本身是区分不了聚合和组合的。如果一定要区分，那么如果在删除整体对象的时候，必须删掉部分对象，那么就是组合关系，否则可能就是聚合关系。从业务角度上来看，如果作为整体的对象必须要部分对象的参与，才能完成自己的职责，那么二者之间就是组合关系，否则就是聚合关系。

例如，汽车与轮胎，汽车作为整体，轮胎作为部分。如果用在二手车销售业务环境下，二者之间就是聚合关系。因为轮胎作为汽车的一个组成部分，它和汽车可以分别生产以后装配起来使用，但汽车可以换新轮胎，轮胎也可以卸下来给其它汽车使用。如果用在驾驶系统业务环境上，汽车如果没有轮胎，就无法完成行驶任务，二者之间就是一个组合关系。再比如网上书店业务中的订单和订单项之间的关系，如果订单没有订单项，也就无法完成订单的业务，所以二者之间是组合关系。而购物车和商品之间的关系，因为商品的生命周期并不被购物车控制，商品可以被多个购物车共享，因此，二者之间是聚合关系。



###### 其他关系或符号

**1. 接口**

接口是未给出实现的对象行为的描述，接口包含操作，但没有属性，一个或多个类可以实现接口，每个类实现接口的操作。

![img](UML笔记.assets/v2-b60963c90ee5ddbb4dafedade48cdd49_720w.jpg)



**2. 注释**

![img](UML笔记.assets/v2-2d4f6ce199434a5098a44b55cdb39310_720w.jpg)



**3. 依赖**

依赖指明两个或两个以上模型元素之间的关系。

依赖有很多种类，比如：实现（realize）、使用（usage）、实例化（instantiate）、调用（call），派生（derive）、访问（access）、引入（import）、友元（friend）等等。

![img](UML笔记.assets/v2-30d2b3eadfbd840f1950db4b19af98cd_720w.jpg)



**4. 实现**

实现是依赖的一种，但由于它具有特殊意义，所以将它独立讲述。

实现是连接说明和实现之间的关系。

![img](UML笔记.assets/v2-6b8a2790872d0ef84795242da0297ce9_720w.jpg)



**5. 约束**

约束用来表示各种限制，如关联路径上的限制，和属性特征检测（存在、所有）。

![img](UML笔记.assets/v2-8081f487efb254a35d69fdfa9547c6f6_720w.jpg)



###### 例题：商场购物卡

- 若某商场中发行一种**购物卡**，**用户**可以根据自己的需要提出**申请去办理购物卡**。
- 商场的**卡管理员**可以根据申请，**创建新的购物卡**。
- **用户**可以向购物卡**预存费用**，商场**卡管理员**为该用户**添加**相应的**预存费用**。
- **用户**可以用购物卡在商场进行**消费**，每进行一次消费，**售货员**就从购物卡中**扣除**相应的**费用**。
- 当购物消费每满一定数额时，**商场**自动在卡中**添加奖励费**。

**分析：**

- **购物卡**是一个类。
- 直接对购物卡类进行操作的有**商场卡管理员类**和**售货员类**，商场卡管理员和售货员都是用户，他们继承**用户类**的特性。
- 商场卡管理员可以添加预存费用，形成一个**加款记录类**。
- 售货员可以从卡中扣除费用，形成一个**消费记录类**。
- 当消费每满一定数额时，商场会在卡中添加奖励费，形成一个**奖励记录类**。

![img](UML笔记.assets/v2-80fe5349740eacf84805c92812831a91_720w.jpg)

----



##### 对象图 (Object Diagram)

类图用于说明类以及类之间的关系，但是它相对抽象，有时会比较难理解。比如下面的例子：

<img src="UML笔记.assets/v2-5e6d83cd61f98fd5cc97004088757db0_720w.png" alt="img" style="zoom:80%;" />



上图是一个图形编辑软件的例子，我们有一个超类Shape和它的五个子类。其中ShapeComposite可以管理其他的Shape。还有一个Canvas类，管理ShapeComposite。

这些是好理解的部分。那么以下的部分呢？

比如说，ShapeComosite也是Shape的一种，也可以被另外一个ShapeComposite管理，这种关系可以无限次迭代。这一点就会稍微有一些难度。

UML对于这种问题给出的答案就是对象图（object diagram），用它来表示系统某一时刻各类的实例以及实例之间关系。

我们继续举例：假设有人使用软件画了下面一幅图。

<img src="UML笔记.assets/v2-366631f0b51aa1f84c14280bbcb4ad4a_720w.png" alt="img" style="zoom:80%;" />



上图中三角形，椭圆形，长方形共同组成了一个复合图形，另外还有一个文本输入框。这个例子的对象图画出来就是下面这样：

<img src="UML笔记.assets/v2-78444373b465d33c7cf3b7096e50d42d_720w.png" alt="img" style="zoom:80%;" />

上图中，：Triangle，：Ellipse，：Rectangle组合成为一个复合图形Lamp：ShapeComposite，而Lamp：ShapeComposite又和ABC：TextBox一起被All：ShapeComposite管理。最后是Canvas对象，作为对象树的根节点管理着All：ShapeComposite对象。

对象图也可以说是系统的快照。



**对象图要素**

对象图主要有两种要素，对象和链接。

对象表示为中间被水平横线分割的矩形。上半部分用于显示对象名和类名。语法为：objectname:classname。其中下划线是必须的，objectname是可以省略的；下半部分用于显示对象的属性值。语法为attributename：type=value，其中type可以省略。属性值可以有多个，每个占一行。

链接是对象之间的连线，是关联等的实例。链接端也可以有代表角色的名称。

----



##### 构件图 (Component Diagram)



###### 一、基本概念

构件图描述构件及其相互依赖关系，构件是逻辑体系结构---类、对象和它们间的关系和协作中定义的概念和功能在**物理体系结构中的实现**。

**构件**：相对逻辑设计上的类和对象，构件是和物理系统相关的一个概念，不同的语言对构件的定义有所不同，UML中的构件含义包括**代码文件，也指数据库、动态链接库、web页面**等。



###### 二、基本元素

构件图的主要元素包括**构件、接口和依赖关系**。

**1. 构件**

构件是定义了良好接口的物理实现单元，是系统中可替换的物理部件。

构件可以是源代码构件、二进制构件或一个可执行的构件。

在UML中，构件**用一个左侧带有突出两个小矩形的矩形来表示**。

<img src="UML笔记.assets/v2-6dce3a2ef8d919a9fde2bb929c6d5e6a_720w.jpg" alt="img" style="zoom:80%;" />

对于一个构件而言，它有**两类接口**：**提供（provided）接口**和**所需（required）的接口**。

标识接口的构件表示方法有3种。

<img src="UML笔记.assets/v2-c5c53df4e05a0db92fce5747201b387b_720w.jpg" alt="img" style="zoom:80%;" />



**2.依赖关系**

构件间的关系以依赖的形式表达。把提供服务的构件称为提供者，把使用服务的构件称为客户。

在UML中，构件图中依赖关系的表示方法与类图中依赖关系相同，都是**一个由客户指向提供者的虚线箭头**。

<img src="UML笔记.assets/v2-4beaa445183f960ef490bf93d1bd0d8e_720w.jpg" alt="img" style="zoom:80%;" />



**3. 接口**

接口用于描述构件所提供的服务的一组操作集合，指定了构件的外部可见操作。可以通过接口访问一个构件。

接口和构件之间的关系分为两种：

- 实现关系（Realization）
- 依赖关系（Dependency）

在UML图中，**接口和构件**之间用**实线**连接表示**实现关系**；而**接口和构件**之间用**虚线箭头**连接则表示**依赖关系**。

<img src="UML笔记.assets/v2-b6ffee3d37fda6110e00dbffb3309543_720w.jpg" alt="img" style="zoom:80%;" />

- 导出接口由提供操作的构件提供。
- 导入接口供访问操作的构件使用。



###### 例题：**对系统实现的体系结构进行建模**

<img src="UML笔记.assets/v2-22fdda2084cb10df57a0fb394701e358_720w.jpg" alt="img" style="zoom:80%;" />



###### 例题：对源代码结构建模

<img src="UML笔记.assets/v2-1dc6bb8d8207f783b962dc34a2828912_720w.jpg" alt="img" style="zoom:80%;" />

----



##### 部署图 (Deployment Diagram)



###### 一、基本概念

部署图表示的是如何将**具体软件制品（例如可执行文件）分配到计算节点**（具有处理服务的某种事物）上。

部署图表示了**软件元素在物理架构上的部署，以及物理元素之间的通信**。

部署图的组成元素：包括**节点、节点间的连接**。连接把多个节点关联在一起，构成一个部署图。



###### 二、基本元素

**1. 节点**

节点代表一个运行时计算机系统中的**硬件资源**。节点通常拥有一些内存，并具有处理能力。例如一台计算机、一个工作站等其它计算设备都属于节点。

在UML中，节点用一个**立方体**来表示。

![img](UML笔记.assets/v2-c5d0832d31daa6630357cb24e2927681_720w.jpg)

按照节点**是否有计算能力**，把节点分为两种类型：**处理器**和**设备**，分别用**构造型《Processor》**和**构造型《Device》**表示处理器和设备。

![img](UML笔记.assets/v2-bd6f2b80ea4686e049f932752c199c8b_720w.jpg)

![img](UML笔记.assets/v2-9a9efb28ea5eda27f9bac46afaa47c9e_720w.jpg)

- **处理器节点（Processor）：**处理器是能够执行软件、具有计算能力的节点。
- **设备节点（Device）**：设备是没有计算能力的节点，通常情况下都是通过其接口为外部提供某种服务，例如打印机、IC读写器，如果我们的系统不考虑它们内部的芯片，就可以把它们看作设备。



**2.节点间的连接**

节点之间的连接表示节点之间**物理连接**以及其上用的**通信协议**。用**直线**表示。

<img src="UML笔记.assets/v2-636cd43d481385248d0731f9d8ebfd12_720w.jpg" alt="img" style="zoom:80%;" />



**3.构件分配到节点**

<img src="UML笔记.assets/v2-1ff5fcddfe81e4dd9a3b8ab9cb9ab197_720w.jpg" alt="img" style="zoom:80%;" />

----



##### 包图 (Package Diagram)

包图是基本静态图的组合，属于**静态图**。

UML包图通常用于描述系统的**逻辑架构**——**层、子系统、包**等。层可以建模为UML包。例如，UI（用户界面）层可以建模为名为UI层的包。UML包图分层组织元素的方式也可以嵌套。



###### 一、包表示法

UML包用一大一小两个矩形组合而成。

如果内部显示了其成员，则包名称标在上面的小矩形内，否则可以标在包内。

<img src="UML笔记.assets/v2-c0e5745307bfe7e38f00689d822aaf80_720w.jpg" alt="img" style="zoom:80%;" />



###### 二、元素的可见性

访问包中的任何元素提供的服务取决于单个元素的可见性，包括内嵌的包。元素的可见性由包容的包所定义，可以是公有的或私有的。

可见性是从包容的包的角度来定义的，包为它包含的元素提供了命名空间。因为包提供了命名空间，所以每个被包容的元素都有唯一的名称，至少是同类型的其他元素范围内有唯一的名称。

- 公有（+）：对它所在的包（包括内嵌的包）以及外部的元素可见。
- 私有（-）：只对它所在的包和内嵌的包可见。

在一张图中，这种**可见性表示法被放在元素名称的前面**。

GardeningPlan类具有公有可见性，允许其他元素访问它，而PlanAnalyst类具有私有可见性。

![img](UML笔记.assets/v2-c611bf2aecf842ac93c977a620f13a82_720w.jpg)



###### 三、依赖关系

UML元素（包括包）之间的依赖关系是用一个**虚线的开放箭头**来表示的。

箭头的尾部位于具有依赖性的元素（**客户**），**箭头**位于支持这种依赖的元素（**提供者**）。

**依赖关系**可以标上**标签**，通过在书名号（《》）中包含依赖关系的类型（由一个关键词来表示），强调元素间依赖关系的类型。

如果两个包之间存在多个包容元素依赖关系，这些依赖关系会聚合为包层面的依赖关系。**如果这些依赖关系是不同类型的，包层面的依赖关系就不提供标签**。

包特有的**依赖关系**包括**导入、访问和合并**，由于包含的元素之间的关系而导致的包间依赖关系包括**跟踪、派生、精化、允许和使用**。

<img src="UML笔记.assets/v2-76c64e25683e761b9ce1e931844495c4_720w.jpg" alt="img" style="zoom:80%;" />

<img src="UML笔记.assets/v2-fc71edbaea1834c1480857ac6d488587_720w.jpg" alt="img" style="zoom:80%;" />

上图右3个层：UI层、Domain层和Technical Services层。

- UI层主要处理与用户交互的类。
- Domain层包含处理业务的主要类和包。
- Technical Services层主要处理一些低层的服务，如持久性服务、定价服务和登录服务等。

<img src="UML笔记.assets/v2-f32add4537ad089035bdbebfbc195213_720w.jpg" alt="img" style="zoom:80%;" />



---



#### 行为型的图 (Behavior Diagram)



##### 活动图 (Activity Diagram) 一

活动图描述系统元素的活动。UML活动图通过提供特定的场景内交流的图形化表示来**补充用例**。

活动图通常既能表示控制流又能表示数据流。

活动图提供了活动流程的可视化描述，可以是在系统、业务、工作流或其他过程中。这些图关注被执行的活动以及谁（或什么）负责执行这些活动。

动态图（activity diagram，活动图）是阐明了业务用例实现的工作流程。业务工作流程说明了业务为向所服务的业务主角提供其所需的价值而必须完成的工作。业务用例由一系列活动组成，它们共同为业务主角生成某些工件。工作流程通常包括一个基本工作流程和一个或多个备选工作流程。工作流程的结构使用活动图来进行说明。

业务用例工作流程说明了业务为向所服务的业务主角提供其所需的价值而必须完成的工作。业务用例由一系列活动组成，它们共同为业务主角生成某些工件。工作流程通常包括一个基本工作流程和一个或多个备选工作流程。工作流程的结构使用活动图来进行说明。

工作流程活动图用于研究实现业务目标时所要执行的各项任务或活动的顺序安排。**活动既可以是手动执行的任务，也可以是自动执行的任务。它可完成一个工作单元**

**活动图是状态图的一种特殊形式**。其中所有或多数状态都是活动状态，而且所有或多数转移都在源状态中的活动完成时立即触发。



###### 一、基本概念

**1. 活动节点**

用来表示一个**活动**。

<img src="UML笔记.assets/v2-4a659245eedddb888073589e07b686d9_720w.jpg" alt="img" style="zoom: 50%;" />



**2. 初始节点和活动终点**

**实心圆**表示**初始节点**（只有一个），**圆圈内加一个实心圆**来表示活动**终点**（可有多个）。

<img src="UML笔记.assets/v2-ddfbfd6f9ea32999da8022101cb602a7_720w.jpg" alt="img" style="zoom:67%;" />



**3. 转换**

一条**带箭头的直线**来表示。 一旦前一个活动结束马上转到下一个活动（无触发转换）。

<img src="UML笔记.assets/v2-71454d6c8f60a52b0d9085365e339cd6_720w.jpg" alt="img" style="zoom:67%;" />



**4. 分支与监护条件**

**分支**是用**菱形**表示的，它有**一个进入转换**（箭头从外指向分支符号），**一个或多个离开转换**（箭头从分支符号指向外）。而**每个离开转换上都会有一个监护条件**，用来表示满足什么条件的时候执行该转换。

<img src="UML笔记.assets/v2-d0462a1230d566b8f21e720b32756470_720w.jpg" alt="img" style="zoom:80%;" />



**5. 分叉与汇合**

**分叉**用于将动作流分为两个或者多个并发运行的分支，而**汇合**则用于同步这些并发分支，以达到共同完成一项事务的目的。

- **分叉**可以用来描述并发线程，每个分叉可以有一个输入转换和两个或多个输出转换，每个转换都可以是独立的控制流。
- **汇合**代表两个或多个并发控制流同步发生，当所有的控制流都达到汇合点后，控制才能继续往下进行。

<img src="UML笔记.assets/v2-3bf09d31dbded2453403a76865d5993f_720w.jpg" alt="img" style="zoom:80%;" />



###### 例题：处理订单

![img](UML笔记.assets/v2-6d9d3dc155bc4f2a9bc47b5f84d79296_720w.jpg)



###### 例题：饮料机

![img](UML笔记.assets/v2-2219e76c264b835778365af494a2c887_720w.jpg)



活动图类似于程序流程图

<img src="UML笔记.assets/v2-32aa20474854839d8b35406ad7f8ea1d_720w.jpg" alt="img" style="zoom:80%;" />

<img src="UML笔记.assets/image-20211227173849583.png" alt="image-20211227173849583" style="zoom:80%;" />

![](UML笔记.assets/v2-c3287d2ca8075dea3e3e4f9d733b5778_1440w.jpg)

----



##### 活动图 (Activity Diagram) 二

活动图和用例图类似，也是描述行为的图，不同在于活动图描述的是活动（activity）的流程。他从 when 和 how 的维度来表达对应的事件。

###### 使用场景

一般活动图会配合用例图一起使用，我们通常使用用例图表达产品需求，确定功能的系统边界，接着通过活动图来表达用例之间的流程。 用例图是需求结构化的表达，能够比较容易的看到系统包含哪些功能，是静态的，单纯从用例图没办法了解用例之间是怎么流通的，因此我们会通过活动图来配合，表达出用例的流程



###### 活动图元素

**活动（activity）**

> Activity is a parameterized behavior represented as coordinated flow of actions.

[官网](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/activity-diagrams.html)的描述很抽象，我们可以简单的理解为流程中的一个环节，配合用例图来表达产品需求时，activity 即代表用例。最简单的活动图，即是两个 activity 通过箭头，表示出两个 activity 的顺序。

<img src="UML笔记.assets/v2-4d915584c2329b9f39fe144da1d5d721_720w.jpg" alt="img" style="zoom:80%;" />



**起点与终点（Initial Node & Activity Final Node）**

活动图**必须**有起点和终点，因为一个业务流程，必然会包含开始和结束，这样的限制能够很好的辅助我们去识别业务的关键点。

<img src="UML笔记.assets/v2-27e5af1379f8c58001dffde7228db2b9_720w.jpg" alt="img" style="zoom:80%;" />

<img src="UML笔记.assets/v2-8fdf6ba38f50a215b272bf6339a26448_720w.jpg" alt="img" style="zoom:80%;" />



**决策与合并（decision node & merge node）**

一个简单的活动图，可以由起点、终点、活动三个要素组成，但是仅仅这三个元素，没办法表达出类似下边的复杂场景： 网购时，用户查看物品，可以选择先添加到购物车，后在购物车进行付款，也可以选择直接付款。 因此 UML 引入了决策与合并的模型，用于表达分支流程。

<img src="UML笔记.assets/v2-d53209e56a318d2d82f7e6b3806b67c2_720w.jpg" alt="img" style="zoom: 67%;" />

这里有一点需要注意，一个 activity node（活动节点），当使用 decision node （决策节点）来实现分支流程时，如果多个分支流程最终都走向同一个流程，需要引入 merge node （合并节点）来表达，如上图的支付流程。



**分叉与加入（fork node & join node）**

有了决策与合并，看似能覆盖多数场景了，但是还是有一些场景没办法满足，还是看网购的场景，当用户支付成功后，**同时**进行微信提醒和短信提醒。已知的图例没办法表达出**同时**的场景，因此 UML 使用了分叉与加入（ fork&join） 的方式来进行表达。分叉（for）表示流程从这里开始并行出多个子流程，加入（join） 表示子流程从这里汇集，所有子流程完成之后，开始进行下一个流程。

<img src="UML笔记.assets/v2-94f56941c141c01f6f4e39d1ed8940e3_720w.jpg" alt="img" style="zoom:80%;" />

**泳道（partitions）**

有了决策与合并、分叉与加入，活动图已经基本满足大多数场景了，但是似乎还不够完美，特别是当我们使用活动图配合表达用例图中的用例流程时，会发现单一的活动图，很难看出角色之间是如何交互的，比如下图：

<img src="UML笔记.assets/v2-c360aa59c6f787be2239096a196150a8_720w.jpg" alt="img" style="zoom:80%;" />

这个活动图中，我们没法看出这个流程有几个角色参与了，每个角色所处的流程在哪。

为了解决这个问题，UML 引入了泳道的概念，把 activity 进行分组。对应在用例图时，每个泳道就可以代表一个角色，泳道里的活动即对应角色的用例。

<img src="UML笔记.assets/v2-630daaef9949d3f1e3f6c1fea4079198_720w.jpg" alt="img" style="zoom:80%;" />

对比不难发现，用了泳道图之后，角色之间如何互动就清晰很多了。



**小结**

活动图涉及的元素比较多，这里简单做个小结 

1. 活动图必须有起点和终点 
2. 活动图的流程节点叫做 activity，起点、终点与 activity 已经可以组成最简单的活动图 
3. 决策用于实现分支流程，当分支流程最终走向同一个流程时，应使用合并（merge node）
4. 分叉用于实现并行流程，加入用于表达多个子流程结束后，再执行下一个流程的场景 
5. 使用泳道可以为 activity 分类，配合用例图表达需求时，每个泳道可以作为一个角色

---



##### 状态机图 (State Machine Diagram) 一



###### 状态图与活动图的联系和区别

（1）活动图是状态图的一种特殊形式。其中所有或多数状态都是活动状态，而且所有或多数转移都在源状态中的活动完成时立即触发。

（2）活动图，就是一个活动到另一个活动详细的处理过程。状态图，就是一个对象生命周期之内的状态的转换。

（3）活动图（Activity Diagram）是由状态图变化而来的，它们各自用于不同的目的。状态图着重描述了对象的状态变化以及触发状态变化的事件。但是，从系统任务的观点看系统，它是由一系列有序活动组成的，活动图是从活动的角度描述系统任务，并且**可以描述系统任务中的并发活动**。**活动图描述了系统中各种活动的执行顺序**，刻画一个方法中所要进行的各项活动的执行流程。活动图显示动作及其结果，着重描述操作实现中完成的工作以及用例或对象内部的活动。此外，在状态图中状态的变迁通常需要事件的触发，而活动图中一个活动结束后将立即进入下一个活动。



###### StateMachine|状态机

状态机由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作、完成特定操作的控制中心。状态机简写为FSM（Finite State Machine），

主要分为2大类：

- 第一类，若输出只和状态有关而与输入无关，则称为Moore状态机
- 第二类，输出不仅和状态有关而且和输入有关系，则称为Mealy状态机



**状态图**

状态图(Statechart Diagram)是描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应。通常我们创建一个UML状态图是为了以下的研究目的：研究类、角色、子系统、或组件的复杂行为。

状态图用于显示状态机（它指定对象所在的状态序列）、使对象达到这些状态的事件和条件、以及达到这些状态时所发生的操作。

状态图（Statechart Diagram）主要用于描述一个对象在其生存期间的动态行为，表现为一个对象所经历的状态序列，引起状态转移的事件（Event），以及因状态转移而伴随的动作（Action）。一般可以用状态机对一个对象的生命周期建模，状态图用于显示状态机（State Mac hine Diagram），重点在与描述状态图的控制流。

如下图例子，状态机描述了门对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作（Action）.

<img src="UML笔记.assets/v2-efb22de8cdc2522a08598a8272fd89d8_1440w.jpg" alt="状态图Statechart Diagram  总结" style="zoom:80%;" />



###### 何时使用状态机

状态机是用于描述有逻辑顺序的电路。即在拿到一个模块的功能描述后，有类似“先....然后...再”或者“如果....如果...."这类描述的时候，可以考虑使用状态机。

关于何时使用状态机，这里介绍两种常见的情况：

- 第一种思路，从状态入手，如果一个模块有比较明显的时序顺序或者逻辑顺序，可以将其划分成不同的状态，然后考虑什么时候进行状态跳转。
- 第二种思路是从输出入手，一个模块要输出数据，什么时候（状态）输出什么样的数据，什么时候改变输出的数据（状态的跳转和输入），通过这样的形式来进行回溯。

无论那种思路，使用状态机的目的都是要控制某部分电路，完成某种具有逻辑顺序或时序规律的电路设计。 其实对于逻辑电路而言，小到一个简单的时序逻辑，大到复杂的微处理器，都适合用状态机方法进行描述。

![img](UML笔记.assets/v2-89c02a73baf74887839ea675ff458346_720w.jpg)



**状态机基本要素与分类**

状态机的基本要素有 3 个，它们是：状态、输出和输入。

- 状态：也叫状态变量。在逻辑设计中，使用状态划分逻辑顺序和时序规律。可以使用one-hot或者二进制编码来作为状态变量，更好的办法是使用电路中已有的信号的不同值来作为状态变量，这样可以大大节省电路资源，不必要创建新的信号。比如一些协议转换时候输入编码的某几位功能位。
- 输出：输出指在某一个状态时向外界输出的信号，常常是控制信号，比如读写信号，使能信号。
- 输入：指状态机中进入每个状态的条件，有的状态机没有输入条件，其中的状态转移较为简单，有的状态机有输入条件，当某个输入条件存在时才能转移到相应的状态。

根据状态机的输出是否与输入条件相关，可将状态机分为两大类：**摩尔（Moore）型状 态机和米勒（Mealy）型状态机**

- **摩尔状态机：摩尔状态机的输出仅仅依赖于当前状态，而与输入条件无关。**
  - 电路的输出仅仅与各触发器的状态， 不受电路输入信号影响或无输入

<img src="UML笔记.assets/v2-b71ddd02fb2536d8c48f0f41914980ef_720w.jpg" alt="img" style="zoom:80%;" />

- **米勒型状态机：米勒型状态机的输出不仅依赖于当前状态，而且取决于该状 态的输入条件。**
  - 电路的输出信号不仅与电路当前状态有关， 还与电路的输入有关

<img src="UML笔记.assets/v2-6fa48c7487a688cc1abc51a79009a732_720w.jpg" alt="img" style="zoom:80%;" />



**状态机的描述通常有三种方法， 称为一段式状态机， 二段式状态机和三段式状态机。**



**状态机的基本描述方式**

一般用于状态机状态描述的方法有2种，分别是：状态转移图，和 HDL 语言描述。

- 状态转移图：状态转移图是状态机描述的最自然的方式。经常在设计规划阶段定义逻辑功能时使用，也可以在分析代码中状态机时使用，通过图形化的方式非常有助于理 解设计意图。使用一些EDA工具也可以生成状态转移图便于进行分析，当然前提是HDL代码的书写要规范。
- HDL 语言描述状态机，目前对于状态机有一些固定规范的描述方法，可以使 HDL 语言描述的状态机更安全、稳定、高效、易于维护。



**一个好的状态机**

一个好的状态机要满足以下要求，其实也是所有设计都要满足的要求：

- 功能正确。要能够覆盖所有的可能情况，并且状态转移要合理且完备，确保不会进入死循环和未知状态，而且由于某些扰动进入非设计状态，也能很快的恢复到正常的状态循环中来。
- 可综合，不能使用folk，function这些关键字。
- 速度快，满足设计的频率要求。任何 RTL 设计都应该满足设计的频率要求。
- 面积小，满足设计的面积要求。在工艺节点更小的现在，面积已经不是最主要的考虑因素了。
- coding style要标准，清晰易懂。这里一是为了便于后续维护，二是为了便于EDA工具进行更好的分析和优化。

当然速度快和面积小很多时候是互相制约的，简单理解，更少的逻辑资源来实现同样的功能就需要花更多的时间来进行资源共享。举个最简单的例子就是除法器，设计成状态机可能需要多个时钟周期，但只需要一个减法器。而如果使用更多的逻辑资源设计成硬件除法器，可能一个时钟内就能完成。另外比如，为了保证安全性，如果将所有的状态都枚举出来进行分别处理，这样虽然可以方便debug，但会占用太多资源，有时候也会影响timing qor。

----



##### 状态机图 (State Machine Diagram) 二

<img src="UML笔记.assets/image-20211227182551720.png" alt="image-20211227182551720" style="zoom:80%;" />

<img src="UML笔记.assets/v2-f1269de7181862d2877530f11dcf0bed_720w.jpg" alt="img" style="zoom:80%;" />

**状态图的外面包围着一个方框，表示这是一个状态机。**









----



##### 通信图 (Communication Diagram)



----



##### 用例图 (Use Case Diagram) 一



###### 概念

先看[官网](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/use-case-diagrams.html)怎么说的：

> Use case diagrams are usually referred to as behavior diagrams used to describe a set of actions (use cases) that some system or systems (subject) should or can perform in collaboration with one or more external users of the system (actors). Each use case should provide some observable and valuable result to the actors or other stakeholders of the system.

简单来说，用例图是用于描述行为的图，他用于描述一系列角色（actors）与用例（use case）之间的关系。因此，通过用例图，我们能够知道系统中涉及到的角色、以及每个角色都能通过这个系统做什么。 一般我们描述事件，可能会使用 5W1H 的方式来表达，对应来看，用例图便是从 who&what 的维度来表达设计。（5W1H : What、Why，Who，Where，When，How）



###### 使用场景

从概念我们得知，用例图用于描述系统中的角色对应的行为，因此比较适合通过用例图来表达产品需求，确定系统边界。 用例图和用户故事（user story）表达的模式是相似的，作为 xx （actor），我希望通过 xx 方式（use case），以便我可以 xx （用户原始诉求）。 当然，在表达产品需求时，用户故事和用例并不完全是一一对应的关系，我们可能会对用例进行归类，不过这就是需求分析的维度了，不在这篇文章阐述的范围。



###### 用例图元素

元素的具体表达方式，请参考[官网](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/use-case-diagrams.html)，本篇文章重点在于说明每个元素具体的含义

###### 角色（actor）

> An actor is behaviored classifier which specifies a role played by an external entity that interacts with the subject (e.g., by exchanging signals and data), a human user of the designed system, some other system or hardware using services of the subject.

**角色代表的是直接或间接使用这个系统的用户或系统、设备**。在面向用户的产品中，角色可能是人，比如学生，在面向技术的产品中（比如 broker，mq），则角色可能是客户端，业务系统。

在实践的过程中，我碰到一些同学会把具体的人名作为将角色，比如王大胖，这是不正确的。actor 表示的是 role（角色），即一类用户的标识，比如学生、厨师、客户端、系统等等。



<img src="UML笔记.assets/v2-2d133d25b86376f325d87773f3689368_720w.png" alt="img" style="zoom:90%;" />



###### 用例（use case）

> Use cases allow to capture requirements of systems under design or consideration, describe functionality provided by those systems, and determine the requirements the systems pose on their environment.

**用例就是角色能够执行的动作，描述了角色能够怎么使用我们提供的系统**。他表达的是一个系统的功能，比如用户注册、添加购物车、支付等等。



<img src="UML笔记.assets/v2-a5c62ee115597d63c329bf9e852eff9a_720w.jpg" alt="img" style="zoom: 50%;" />



###### 包含关系（include relationship）

> Use case include is a directed relationship between two use cases which is used to show that behavior of the included use case (the addition) is inserted into the behavior of the including (the base) use case.

**包含关系，顾名思义，即表达一个用例（基础用例）包含另一个用例（新增用例）的场景。一般是某个用例包含很大的范围，专门抽出子用例来着重表达，又或者是复用用例。**

- 强化表达子用例的例子：

<img src="UML笔记.assets/v2-634390ac0b2fb4c445b4b425d24e9d7c_720w.jpg" alt="img" style="zoom: 50%;" />



- 复用用例的例子：

<img src="UML笔记.assets/v2-bb69fe085fe4cfce9d15088661dec995_720w.jpg" alt="img" style="zoom:50%;" />



###### 扩展关系 （extend relationship）

> Extend is a directed relationship that specifies how and when the behavior defined in usually supplementary (optional) extending use case can be inserted into the behavior defined in the extended use case.

扩展关系表明的是一个用例（基础用例）执行过程中的可选过程，基础用例本身可以完整的场景，扩展用例作为一个**可选（optional）**过程插入到基础用例中。比如用户注册的场景，注册本身可以作为一个单独的用例，但是在注册的过程中，用户可以寻求帮助，查看注册指引，那么获取帮助就是一个可选的流程，整个用例场景我们就可以这么表达：

<img src="UML笔记.assets/v2-3e0944726b19f999937a7fdd79fee3f7_720w.jpg" alt="img" style="zoom:60%;" />



注意，**可选（optional）**是一个很主观的描述，比如丰巢的取件过程，取件是一个基础用例，取件时，如果快递放置的时间长，可能要扫码支付费用，那么支付费用这个用例到底是包含用例还是扩展用例，则取决于产品定义，是 optional 还是 alternative，直观的来看，就是看弹出支付窗口时，能不能跳过，如果能跳过，则是 optional，属于扩展用例，否则属于包含用例



**官网用例图**

- Business Use Case Diagrams

![](UML笔记.assets/business-use-case-diagram-elements.png)



- System Use Case Diagrams

![](UML笔记.assets/use-case-diagram-elements.png)





###### 具体描述

- Usecase：用例即系统的功能
- Actor：系统的参与者
- Association：关联关系
- DirectedAssociation：直接关联关系
- Generization：泛化关系，即继承关系
- Dependency：依赖关系
- Inducle：包含关系
- Extend：扩展关系



<img src="UML笔记.assets/image-20211013155215620.png" alt="image-20211013155215620" style="zoom:70%;" />



<img src="UML笔记.assets/image-20211013155306545.png" alt="image-20211013155306545" style="zoom: 60%;" />

<img src="UML笔记.assets/image-20211013162700519.png" alt="image-20211013162700519" style="zoom:70%;" />

如图，该用例图反映了三个参与者即：客户、职员、银行三个参与者的功能和关系。

客户依赖职员来完成存款、转账、取款功能。而职员又可以有登陆和维护账户的功能。

跨行转账和本行转账同属于转账范畴，因此使用了继承关系，就例如类与对象的关系一样。又例如支付手段有：微信支付、银联支付、支付宝支付那样。这三种支付手段同一继承到支付手段上。



<img src="UML笔记.assets/image-20211013163108028.png" alt="image-20211013163108028" style="zoom:67%;" />

<img src="UML笔记.assets/image-20211013164347302.png" alt="image-20211013164347302" style="zoom:80%;" />



用例之间的关系只要包括三种，分别是**扩展**、**包含**和**继承**。

**包含关系**：从基用例指向扩展用例。指的是在执行基用例之前**必须**先执行扩展用例，同时可以做功能的分解功能（一般用的比较少）。上边的图片就是用作功能的分解。

**扩展关系**：从扩展用例指向基用例。一般在执行基用例之前看看是否符合扩展用例的条件。例如在订购商品之前看看购买者是否是会员，如果是会员就可以进行打折优惠等等。

- 另外在扩展关系中，扩展关系中的基用例是可以单独存在的，在每次执行基础用例之前扩展用例不是都必须被执行。扩展用例依赖于基础用例。而在包含关系中恰恰相反，基用例的执行必须在扩展用例的基础上才可以。

<img src="UML笔记.assets/image-20211013163415425.png" alt="image-20211013163415425" style="zoom:67%;" />

<img src="UML笔记.assets/image-20211013164916550.png" alt="image-20211013164916550" style="zoom:80%;" />

- 下图反映了包含和拓展在一起的时候的一个用例

<img src="UML笔记.assets/image-20211013163503102.png" alt="image-20211013163503102" style="zoom: 60%;" />

<img src="UML笔记.assets/image-20211013165041794.png" alt="image-20211013165041794" style="zoom:80%;" />



**继承关系**：继承关系是将多个扩展用例抽象出一个基用例。类似类和对象的关系，基用例是类而扩展用例是对象，也就是说基用例是生成扩展用例的模板。

其关系主要如下：

<img src="UML笔记.assets/image-20211013163755352.png" alt="image-20211013163755352" style="zoom:67%;" />

<img src="UML笔记.assets/image-20211013165614000.png" alt="image-20211013165614000" style="zoom:80%;" />



**参与者与参与者、参与者与用例、用例与用例之间的关系**：

- ① 参与者与参与者之间的关系：泛化（继承）、依赖关系。
- ② 参与者与用例之间的关系：关联关系。
- ③ 用例与用例之间的关系：泛化、扩展、包含。

**用例粒度：**用例粒度指的是用例所包含的系统服务或功能单元的多少。用例粒度越大，用例包含的功能越多，反之则包含的功能越少。

**用例粒度确定错误所造成的影响**：

① 如果用例粒度过大，造成的用例过多，在后期系统实现过程中可能会出现冗余现象。

② 如果用例粒度过小，可能会造成系统功能不清晰。

在用例建模过程中比较难的可能就是系统功能的提取以及Actor的提炼。另外用例图画出来之后要写用例规约，至于用例规约等等下边的部分下次再写。

---



##### 用例图 (Use Case Diagram) 二

用例图又称用况图，描述**系统功能**。

通过用例图展示待建系统的上下文范围以及它提供的功能。它描述了谁（或什么）与系统交互，外部世界希望系统做些什么。

用例着眼于为用户增加价值，提供了一种捕获**功能需求**的系统且直观的方法，可驱动整个开发过程。用例从某个特定参与者的角度用简单易懂的语言说明**一个特定的使用场景**。



###### 一、基本概念

用例图包括：**参与者、用例、关系**和**边界**四个要素。

**1. 参与者**

与系统交互的**用户**或其他**软硬件系统**，用**小人形**表示。

![img](UML笔记.assets/v2-e60e27953d9aabbeba88630e806c344c_720w.jpg)



**2. 用例**

系统中执行的一系列**动作**，用**椭圆**表示。

![img](UML笔记.assets/v2-40c9fbcf3b9feaf7a3daf6a3b36c1078_720w.jpg)



**3. 关系**

参与者与用例、参与者之间、用例之间的联系。



**4. 边界**

一组用例描述的系统或子系统，用**矩形框**表示。



###### 二、关系

###### （1）参与者之间的关系

- **泛化关系**

<img src="UML笔记.assets/v2-556711a3e4d2878cc091e0766371aa04_720w.jpg" alt="img" style="zoom: 80%;" />



###### （2）参与者与用例之间的关系

- **关联关系**：参与者与用例之间通常用关联关系来描述。**带箭头的实线表示，箭头指向用例**。

<img src="UML笔记.assets/v2-b79ce84bb39d4643e3269d23fad25699_720w.jpg" alt="img" style="zoom:80%;" />

###### （3）用例之间的关系

- **包含关系**：一个用例（基础用例）的行为包含另外一个用例（被包含用例）的行为。基础用例依赖于包含用例的执行结果。**包含关系是通过在依赖关系上应用<<include>>构造型（衍型）来表示的**。**箭头的方向是从基础用例指向被包含的用例**。包含关系是一定要执行的。

**应用情形**：

1. 如果两个以上用例有**重复的功能**，则可以将重复的功能分解到另一个用例中。其他用例可以和这个用例建立包含关系。
2. 一个用例的功能太多时，可以用包含关系创建多个子用例。

<img src="UML笔记.assets/v2-b165a020d2c041f0ade7b362de5b77c9_720w.jpg" alt="img" style="zoom:80%;" />

<img src="UML笔记.assets/v2-b6de5d46e5a89f861f38f498ba4f4366_720w.jpg" alt="img" style="zoom:80%;" />

**扩展关系**：扩展用例可以在基础用例之上添加新的行为，基础用例必须声明某些特定的扩展点，扩展用例只能在这些扩展点上扩展新的行为，将扩展用例的事件流在一定的条件下按照相应的扩展点插入到基础用例中。**扩展关系是通过在依赖关系上应用<<extend>>构造型（衍型）来表示的**。**箭头方向由扩展用例指向基础用例**。扩展关系是当特殊情况下触发的。

<img src="UML笔记.assets/image-20211227143504260.png" alt="image-20211227143504260" style="zoom:80%;" />

**泛化关系**：一个用例可以被特别列举为一个或多个子用例，这被称为用例泛化。当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。泛化关系表示的是**一般与特殊**的关系。

<img src="UML笔记.assets/v2-596be495cd12f201ba6e50d46f4d4eb1_720w.jpg" alt="img" style="zoom:80%;" />



###### 三、用例场景描述

随着与用户更多地交流，分析师为每个标记的功能开发用例。

用例场景详细描述的模板如下表。

![img](UML笔记.assets/v2-4268d74c81aafbef3ac1375b24b8b0e8_720w.jpg)



###### 例题：商场购物卡

- 若某商场中发行一种**购物卡**，**用户**可以根据自己的需要提出**申请去办理购物卡**。
- 商场的**卡管理员**可以根据申请，**创建新的购物卡**。
- **用户**可以向购物卡**预存费用**，商场**卡管理员**为该用户**添加**相应的**预存费用**。
- **用户**可以用购物卡在商场进行**消费**，每进行一次消费，**售货员**就从购物卡中**扣除**相应的**费用**。
- 当购物消费每满一定数额时，**商场**自动在卡中**添加奖励费**。

**分析：**

- **参与者**：购物卡管理员、售货员。
- **用例**：创建新卡、为卡添加预存费用、消费。
- 创建新卡、为卡添加预存费用、消费都需要相关人员**登录**操作。

<img src="UML笔记.assets/v2-5c7ed981cc5a48ae53e9c4c3df311b13_720w.jpg" alt="img" style="zoom:80%;" />

----







##### 时序图 (Timing Diagram) 一

1. 时序图是一种动态图，一般配合组件图、类图使用，表达程序设计过程中的业务流程
2. 时序图与活动图都是表达流程的动态图，但是由于其关注的点不同，因此适用于不同的场景
3. 时序图主要关注消息的交互顺序和类型，适合在程序设计过程中表达对象的交互流程，活动图关注的是 activity 之间的流转过程，适合表达需求层面的业务场景
4. 对象（lifeline）是一个**具体的实例**，因此时序图表达的是系统在一个特定时间范围内几个特定对象之间的交互过程



![UML-时序图](UML笔记.assets/v2-e41fca252d1e6067163151023217756f_1440w.jpg)

序列图是最常见的一种交互图，它关注于多条生命线之间的消息交换。

序列图通过关注交换的消息序列以及它们在生命线上的相应发生规范来描述交互。



###### 使用场景

时序图一般配合组件图、类图一起使用，表明对象之间的通讯流程。 我们在讲到的活动图也是一种动态图，也描述的是流程，但是他们之间关注点会有所区别。活动图粒度比较粗，它只关注 activity 之间是怎么流传的，因此比较适合在需求分析的阶段来表达需求场景。而时序图关注点在于消息交换，转换成代码就是代码调用的流程，因此更适合在程序设计阶段，表达更细节的，更接近程序实现的流程场景。 比如 jQuery 的 ajax 请求，请求时会通过创建一个代理对象，由代理对象来实现 http 请求，这部分用活动图表达就相对困难。 因此虽然活动图与时序图都是表达流程的图，但是由于两种图关注的点有所差别，因而适用于不同的场景。

![img](UML笔记.assets/v2-ef824584590cfc5b325e24d5afa83fcc_720w.jpg)



###### 时序图基本元素

**对象（lifeline）**

> Lifeline is a named element which represents an individual participant in the interaction. While parts and structural features may have multiplicity greater than 1, lifelines represent only one interacting entity.



[对象](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/sequence-diagrams.html%23lifeline)表示**一个具体的实例**对象，敲重点，时序图只表达其中一个实例对象的交互流程，因此如果系统中有多个实例对象，每个实例对象流程有所区别，那么应该画多个时序图。因此时序图表达的是系统某一时段，对象的交互过程。这个对象不仅是一个 class 的实例，也有可能是一个子系统，分布式集群里的某个节点。

![img](UML笔记.assets/v2-50bda1ee2911d079ff4f6e8aaa229522_720w.jpg)



**系统边界（gate）**

> A gate is a message end, connection point for relating a message outside of an interaction fragment with a message inside the interaction fragment.



一个时序图并不一定要求从流程的最开始画起，也不一定会涉及到流程的终点，因此在这个流程里，我们不关注的部分称之为系统边界（gate），表明消息从外部对象产生，最终返回给外部对象。



<img src="UML笔记.assets/v2-f6bcac901546f9b6baa769275f88835f_720w.jpg" alt="img" style="zoom:67%;" />

**控制焦点（execution specification，informally called activation）**

> Execution (full name - execution specification, informally called activation) is interaction fragment which represents a period in the participant's lifetime when it is
> executing a unit of behavior or action within the lifeline, sending a signal to another participant, waiting for a reply message from another participant.



控制焦点表明该对象执行某些方法的过程，或者是进行其他方法调用、等待消息回复的过程。我们可以简单的理解为调用了该对象的某个方法，该方法终止的标志为执行完相关的过程，完成方法调用，并且收到了相关的消息。

如下面的方法 a，控制焦点从a被调用开始，到 `callOtherFunction` 返回，并且收到了 `waitingSomeMessage`消息标记结束

```c
function a() {
    //doSomething()
   event.on('waitingSomeMessage', () => {})
   callOtherFunction()
}
```



**消息（interaction message）**

> Message is a named element that defines one specific kind of communication between lifelines of an interaction. The message specifies not only the kind of communication, but also the sender and the receiver. Sender and receiver are normally two occurrence specifications (points at the ends of messages).

[消息](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/interaction-message.html)不代表通讯的协议，只是表明了发送者向接收者进行了一次通讯，可能会代表一次 http 请求，也可能代表一个函数调用。 消息分为[同步消息](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/interaction-message.html%23synchronous-call)、[异步消息](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/interaction-message.html%23asynchronous-call)、[返回消息](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/interaction-message.html%23reply)、创建消息([https://www.uml-diagrams.org/interaction-message.html#create](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/interaction-message.html%23create))、删除消息([https://www.uml-diagrams.org/interaction-message.html#delete](https://link.zhihu.com/?target=https%3A//www.uml-diagrams.org/interaction-message.html%23delete))等



###### 同步消息

顾名思义，就是消息发送后，等待消息的回复。从代码的角度来说，就是执行了一个函数调用，并且等待函数的返回。

<img src="UML笔记.assets/v2-6f7e4adcd8772e494859c72ce8cd7ee1_720w.jpg" alt="img" style="zoom: 67%;" />



###### 异步消息

是指发送了消息后不等待返回，立即处理后续的事情。从代码的角度来说，就是开了另一个线程执行函数调用，不等待函数的返回结果

<img src="UML笔记.assets/v2-76c7f319ea3497e8b192ddc5dd2a5ee7_720w.jpg" alt="img" style="zoom:67%;" />



###### 返回消息

表明消息接受者已经处理完消息，把结果返回给发送者。从代码的角度来说，就是 A 调用了 B，B 返回了结果（无论是通过函数返回或函数回调的方式）

<img src="UML笔记.assets/v2-4544363456261e8ac0d0f75c72874566_720w.jpg" alt="img" style="zoom:67%;" />



###### 创建消息

即创建对象，A 给 B 发送了创建消息，从代码的角度来说就是在 A 的方法里，执行了 `new B()` 的操作

<img src="UML笔记.assets/v2-c14c35ea2f2d4d55028426dc615d481d_720w.jpg" alt="img" style="zoom:67%;" />



###### 删除消息

和创建对象相反，A 给 B 发送了删除的消息，从代码的角度来说就是在 A 的方法里，执行了 `release B` 的操作，在 C++等手动内存管理的场景会比较好举例，等价于释放了对象的内存

<img src="UML笔记.assets/v2-ab6ca9aeb54016af667827f06a1a0714_720w.jpg" alt="img" style="zoom:67%;" />



###### 异步信号

即创建一个信号发送给接收端，常用于响应式的设计



###### 引用（Interaction use）

> Interaction use is an interaction fragment which allows to use (or call) another interaction. Large and complex sequence diagrams could be simplified with interaction uses. It is also common to reuse some interaction between several other interactions.

引用是表示在现有时序图里嵌入一个子流程，主要是用于简化时序图的表达。因为有些流程相对复杂，如果都画在一起，显得复杂，不好阅读。另一种场景就是复用流程。

<img src="UML笔记.assets/v2-bf3eaa704359df6ec9c3bf6d46538937_720w.jpg" alt="img" style="zoom: 67%;" />

----



##### 序列图 (Sequence Diagram) 二

https://www.uml-diagrams.org/sequence-diagrams.html

序列图说明事件如何引发从一个对象到另一个对象的转移。一旦通过用例确认事件，就可以创建一个序列图。事实上，序列图表现了导致行为从一个类流动到另一个类的关键类和事件。

序列图以栅栏的形式描述对象的交互，其中在右侧添加新创建对象。



**序列图**是最常见的[一种交互图](https://www.uml-diagrams.org/uml-25-diagrams.html#interaction-diagram)，它侧重于多个[生命线](https://www.uml-diagrams.org/sequence-diagrams.html#lifeline)之间的[消息](https://www.uml-diagrams.org/interaction-message.html)交换。

序列图通过关注交换的消息序列以及它们在生命线上的相应发生规范来描述交互。

以下节点和边缘通常绘制在**UML序列图**中：[生命线](https://www.uml-diagrams.org/sequence-diagrams.html#lifeline)，[执行规范](https://www.uml-diagrams.org/sequence-diagrams.html#execution)，[消息](https://www.uml-diagrams.org/interaction-message.html)，[组合片段](https://www.uml-diagrams.org/sequence-diagrams-combined-fragment.html)，[交互使用](https://www.uml-diagrams.org/sequence-diagrams.html#interaction-use)，[状态不变](https://www.uml-diagrams.org/sequence-diagrams.html#state-invariant)，**延续**，[破坏发生](https://www.uml-diagrams.org/sequence-diagrams.html#destruction-occurrence-seq)。

序列图的主要元素如下图所示。

<img src="UML笔记.assets/sequence-diagram-overview.png" alt="UML 序列图的主要元素。" style="zoom:80%;" />



时序图是UML交互图中的一类，又名序列图、顺序图。

用于描述对象之间的传递消息的时间顺序（包括发送消息、接收消息、处理消息、返回消息等）。



###### 一、主要元素

###### **1. 对象**

参与交互的类的**实例**，对象之间可以发送消息和接收消息。在分析模型中可以用**类的类型**表示对象。

<img src="UML笔记.assets/image-20211227153215343.png" alt="image-20211227153215343" style="zoom:80%;" />



###### 2. 参与者

描述本次交互的发起者，即**用例的驱动者**。用**小人形**状表示。

<img src="UML笔记.assets/v2-b6db26e29596b82e0ca716ba463f818d_720w.jpg" alt="img" style="zoom:80%;" />



###### 3. 生命线

生命线用于描述**对象的生存周期**，对象下方的**虚线**就是该对象的生命线。

<img src="UML笔记.assets/v2-7d3bcea752626e1ca18adf387ea43df9_720w.jpg" alt="img" style="zoom:80%;" />



###### 4. 执行规格条/激活条

表示控制焦点的**控制期**，指**活动者或对象处于执行状态的时间段**。用**矩形条**表示。

<img src="UML笔记.assets/v2-32bf377cdd8b63d433964994693b9ed6_720w.jpg" alt="img" style="zoom:80%;" />



###### 5. 消息

消息用于描述对象间交互的方式及内容。

消息（它可能表示事件或操作的调用）被画成**水平**的。

**消息图标的端点与垂直线相连**，这些垂直线又与图顶部的实体相连。消息从发出者指向接收者。次序由垂直位置来表示，第一个消息出现在图的顶部，最后一个消息出现在图的底部。



###### 二、消息类型

**1. 同步消息**

一个对象向另一个对象发出同步消息后，将处于阻塞状态，一直等到另一个对象的回应。

![img](UML笔记.assets/v2-e213c5cb9b69cef98e4ae7de2dbddb15_720w.jpg)



**2. 异步消息**

一个对象向另一个对象发出异步消息后，这个对象可以进行其他的操作，不需要等到另一个对象的响应。

![img](UML笔记.assets/v2-ef5080fe8de5ab0b34bb2c2c380e754c_720w.jpg)



**3. 返回消息**

表示从过程调用返回。

![img](UML笔记.assets/v2-3e871a7963b7af301f07517e03e03754_720w.jpg)



**4. 简单消息**

不区分同步或异步。

![img](UML笔记.assets/v2-fc3aa2303542a0531abf8e5221281590_720w.jpg)



###### 三、消息语法格式

[条件][消息序号][返回值：=]消息名（[参数列表]）

**例如：**

- 2：display( x , y )：简单消息
- 1.2.1：p:= find( specs )：嵌套消息，消息带返回值
- [x<0] 4: invert( x , color ) ：条件消息
- 3.1 * update( )：循环消息



###### 四、销毁事件

销毁事件表明何时一个对象被**销毁**，它表示为生命线末端的一个 **X**。

如果对象是一个组合对象，那么相关的对象也会被销毁。

<img src="UML笔记.assets/v2-9f4c7461da21504b8ae56589ec6b3ec8_720w.jpg" alt="img" style="zoom:80%;" />



###### 五、控制流

有两种方式来修改顺序图的控制流：**使用分支、使用从属流**。

**1. 使用分支**

![img](UML笔记.assets/v2-bdf99eabe05980feebaa297e48c2d311_720w.jpg)



**2. 使用从属流**

从属流允许某一个对象根据不同的条件改变执行不同的操作，即创建对象的另一条生命线分支。

![img](UML笔记.assets/v2-3b747e9e10d51c2c42c9b30c811f681f_720w.jpg)



###### 六、控制结构

序列片段可以用来简化序列图，也可以用来表示序列图中的流程控制结构。

如下图，在序列图中引入一个循环。

![img](UML笔记.assets/v2-c5543ffabfa3e4d0dba9bf14571db413_720w.jpg)

![img](UML笔记.assets/v2-0709d1b46f798ab11278d524d26dbfa7_720w.jpg)

**矩形方框**表示UML图框。**图框操作符**有下列几种：

- **alt**：选择性片段。
- **loop**：条件为真的循环片段。
- **opt**：可选片段。
- **par**：并行执行片段。
- **region**：只能执行一个线段的临界片段。



###### 例题：商场购物卡

- 若某商场中发行一种**购物卡**，**用户**可以根据自己的需要提出**申请去办理购物卡**。
- 商场的**卡管理员**可以根据申请，**创建新的购物卡**。
- **用户**可以向购物卡**预存费用**，商场**卡管理员**为该用户**添加**相应的**预存费用**。
- **用户**可以用购物卡在商场进行**消费**，每进行一次消费，**售货员**就从购物卡中**扣除**相应的**费用**。
- 当购物消费每满一定数额时，**商场**自动在卡中**添加奖励费**。

![img](UML笔记.assets/v2-9d2727c16ceb360535c5c6f6b468276f_720w.jpg)

---



